const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ot=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return W(e,t,s,n,i,1,o,""),n},W=(e,t,s,n,o,u,i,r)=>{const h=u*i;t:for(const c of e.keys())if(c===F){const d=o[h-1];d<=s&&n.set(r,[e.get(c),d])}else{let d=u;for(let l=0;l<c.length;++l,++d){const p=c[l],f=i*d,g=f-i;let a=o[f];const m=Math.max(0,d-s-1),y=Math.min(i-1,d+s);for(let _=m;_<y;++_){const b=p!==t[_],z=o[g+_]+ +b,A=o[g+_+1]+1,w=o[f+_]+1,L=o[f+_+1]=Math.min(z,A,w);L<a&&(a=L)}if(a>s)continue t}W(e.get(c),t,s,n,o,d,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==F&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ut(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ot(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,M(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=M(this._tree,t);let o=n.get(F);return o===void 0&&n.set(F,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},M=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==F&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const h=e.get(u);if(r===u.length)e=h;else{const c=new Map;c.set(u.slice(r),h),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ut=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)R(n);else if(s.size===1){const[o,u]=s.entries().next().value;$(n,o,u)}}},R=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,o)}},$=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},G=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},N=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),P(n.terms,u)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);P(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,o,u)=>{const{k:i,b:r,d:h}=u;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(i+1)/(e+i*(1-r+r*n/o)))},ft=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,ht),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof(console==null?void 0:console[e])=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,o,u,i,r,h=new Map)=>{if(o==null)return h;for(const c of Object.keys(u)){const d=u[c],l=e._fieldIds[c],p=o.get(l);if(p==null)continue;let f=p.size;const g=e._avgFieldLength[l];for(const a of p.keys()){if(!e._documentIds.has(a)){gt(e,l,a,s),f-=1;continue}const m=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!m)continue;const y=p.get(a),_=e._fieldLength.get(a)[l],b=at(y,f,e._documentCount,_,g,r),z=n*d*m*b,A=h.get(a);if(A){A.score+=z,lt(A.terms,t);const w=N(A.match,s);w?w.push(c):A.match[s]=[c]}else h.set(a,{score:z,terms:[t],match:{[s]:[c]}})}}return h},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((a,m)=>({...a,[m]:N(n.boost,m)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:h}=n,{fuzzy:c,prefix:d}={...J.weights,...i},l=e._index.get(t.term),p=B(e,t.term,t.term,1,l,o,u,h);let f,g;if(t.prefix&&(f=e._index.atPrefix(t.term)),t.fuzzy){const a=t.fuzzy===!0?.2:t.fuzzy,m=a<1?Math.min(r,Math.round(t.term.length*a)):a;m&&(g=e._index.fuzzyGet(t.term,m))}if(f)for(const[a,m]of f){const y=a.length-t.term.length;if(!y)continue;g==null||g.delete(a);const _=d*a.length/(a.length+.3*y);B(e,t.term,a,_,m,o,u,h,p)}if(g)for(const a of g.keys()){const[m,y]=g.get(a);if(!y)continue;const _=c*a.length/(a.length+y);B(e,t.term,a,_,m,o,u,h,p)}return p},X=(e,t,s={})=>{if(typeof t!="string"){const d={...s,...t,queries:void 0},l=t.queries.map(p=>X(e,p,d));return Y(l,d.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:h}=i,c=r(t).flatMap(d=>h(d)).filter(d=>!!d).map(ft(i)).map(d=>At(e,d,i));return Y(c,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),o=[];for(const[u,{score:i,terms:r,match:h}]of n){const c=r.length,d={id:e._documentIds.get(u),score:i*c,terms:Object.keys(h),match:h};Object.assign(d,e._storedFields.get(u)),(s.filter==null||s.filter(d))&&o.push(d)}return o.sort(G),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of K(e,t,s)){const r=i.join(" "),h=n.get(r);h!=null?(h.score+=u,h.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:h}]of n)o.push({suggestion:u,terms:r,score:i/h});return o.sort(G),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if((t==null?void 0:t.fields)==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:h,serializationVersion:c},d)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const l=new Et(d);l._documentCount=t,l._nextId=s,l._documentIds=k(n),l._idToShortId=new Map,l._fieldIds=o,l._fieldLength=k(u),l._avgFieldLength=i,l._storedFields=k(r),l._dirtCount=h||0,l._index=new C;for(const[p,f]of l._documentIds)l._idToShortId.set(f,p);for(const[p,f]of e){const g=new Map;for(const a of Object.keys(f)){let m=f[a];c===1&&(m=m.ds),g.set(parseInt(a,10),k(m))}l._index.set(p,g)}return l},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,d=!1)=>{let l="";i===0?l=c.length>20?`… ${c.slice(-20)}`:c:d?l=c.length+i>100?`${c.slice(0,100-i)}… `:c:l=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,l&&o.push(l),i+=l.length,d||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let h=s.indexOf(n,u);if(h===-1)return null;for(;h>=0;){const c=h+n.length;if(r(e.slice(u,h)),u=c,i>100)break;h=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(o=>{const{id:u,terms:i,score:r}=o,h=u.includes("@"),c=u.includes("#"),[d,l]=u.split(/[#@]/),{contents:p}=n[d]??={title:"",contents:[]};if(h)p.push([{type:"customField",key:d,index:l,display:i.map(f=>o.c.map(g=>j(g,f))).flat().filter(f=>f!==null)},r]);else{const f=i.map(g=>j(o.h,g)).filter(g=>g!==null);if(f.length&&p.push([{type:c?"heading":"title",key:d,...c&&{anchor:l},display:f},r]),"t"in o)for(const g of o.t){const a=i.map(m=>j(g,m)).filter(m=>m!==null);a.length&&p.push([{type:"text",key:d,...c&&{anchor:l},display:a},r])}}}),Q(n).sort(([,o],[,u])=>"max"==="total"?xt(o,u):kt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=it(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":338,\"nextId\":338,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-8daa1a0e#相关领域\",\"2\":\"v-2bb655c3\",\"3\":\"v-2bb655c3#_1-算法分析的目标\",\"4\":\"v-2bb655c3#_2-实验结果\",\"5\":\"v-138e0bb4\",\"6\":\"v-138e0bb4#_1-算法的基本概念\",\"7\":\"v-138e0bb4#_2-伪代码编写\",\"8\":\"v-138e0bb4#_3-算法的数学基础\",\"9\":\"v-138e0bb4#_3-1-函数的渐进的界\",\"10\":\"v-05ed915c\",\"11\":\"v-6427756d\",\"12\":\"v-6427756d#_1-数学表示\",\"13\":\"v-6427756d#_2-斯特林近似\",\"14\":\"v-1b9a47b4\",\"15\":\"v-7fa3e1a2\",\"16\":\"v-f9c2c1c0\",\"17\":\"v-f9c2c1c0#_1-公式和字体\",\"18\":\"v-f9c2c1c0#_2-基本\",\"19\":\"v-f9c2c1c0#_3-证明中的符号\",\"20\":\"v-f9c2c1c0#_4-大型运算符\",\"21\":\"v-f9c2c1c0#_4-1-求和\",\"22\":\"v-f9c2c1c0#_4-2-求积\",\"23\":\"v-f9c2c1c0#_5-数论\",\"24\":\"v-16ce8cd6\",\"25\":\"v-16ce8cd6#_1-计数原理\",\"26\":\"v-16ce8cd6#_1-1-加法原理\",\"27\":\"v-16ce8cd6#_1-2-乘法原理\",\"28\":\"v-16ce8cd6#_2-排列组合基础\",\"29\":\"v-16ce8cd6#_2-1-排列数\",\"30\":\"v-16ce8cd6#_2-2-组合\",\"31\":\"v-28bf815b\",\"32\":\"v-28bf815b#_1-生成函数\",\"33\":\"v-28bf815b#_2-常见的组合性质\",\"34\":\"v-28bf815b#附录-组合的有趣性质\",\"35\":\"v-28bf815b#斐波那契数和组合数\",\"36\":\"v-28bf815b#维空间和组合数\",\"37\":\"v-2ff9b25e\",\"38\":\"v-2ff9b25e#_1-定义\",\"39\":\"v-4258002b\",\"40\":\"v-b29b981e\",\"41\":\"v-b29b981e#_1-第一类斯特林数\",\"42\":\"v-78a4f5b4\",\"43\":\"v-78a4f5b4#_1-二分查找\",\"44\":\"v-78a4f5b4#_2-代码实现\",\"45\":\"v-78a4f5b4#_3-标准库实现\",\"46\":\"v-78a4f5b4#_3-1-c-stl-实现\",\"47\":\"v-78a4f5b4#_3-2-c-语言\",\"48\":\"v-78a4f5b4#_3-3-python\",\"49\":\"v-78a4f5b4#_4-二分答案\",\"50\":\"v-78a4f5b4#_5-分数规划\",\"51\":\"v-78a4f5b4#_6-三分法\",\"52\":\"v-5549b110\",\"53\":\"v-5549b110#_1-位运算的功能\",\"54\":\"v-5549b110#_2-位运算优先级\",\"55\":\"v-5549b110#_3-位运算详解\",\"56\":\"v-5549b110#_3-1-按位与\",\"57\":\"v-5549b110#_3-2-按位或\",\"58\":\"v-5549b110#_3-3-异或\",\"59\":\"v-5549b110#_3-4-按位取反\",\"60\":\"v-5549b110#_3-5-左移\",\"61\":\"v-5549b110#_3-6-右移\",\"62\":\"v-5549b110#_3-7-无符号右移\",\"63\":\"v-5549b110#_3-8-公式总结\",\"64\":\"v-5549b110#_4-位运算总结\",\"65\":\"v-5549b110#_4-1-交换两个数\",\"66\":\"v-5549b110#_4-2-快速最小公倍数\",\"67\":\"v-5549b110#_4-3-判断奇偶\",\"68\":\"v-5549b110#_4-4-符号相同\",\"69\":\"v-5549b110#_4-5-第-i-1-位\",\"70\":\"v-5549b110#_4-6-最低有效位\",\"71\":\"v-5549b110#_4-7-绝对值\",\"72\":\"v-009cf31e\",\"73\":\"v-009cf31e#_1-差分数组的定义\",\"74\":\"v-009cf31e#_2-性质\",\"75\":\"v-aae83fba\",\"76\":\"v-aae83fba#_1-快速幂算法\",\"77\":\"v-aae83fba#_1-1-递归版本\",\"78\":\"v-aae83fba#_1-2-非递归版本\",\"79\":\"v-aae83fba#_2-模意义下取幂\",\"80\":\"v-aae83fba#_3-斐波那契数列\",\"81\":\"v-aae83fba#_4-求矩阵的快速幂\",\"82\":\"v-232b9ca2\",\"83\":\"v-aae2cd32\",\"84\":\"v-aae2cd32#_1-前缀和定义\",\"85\":\"v-aae2cd32#_2-前缀和的推广\",\"86\":\"v-aae2cd32#_2-1-后缀和\",\"87\":\"v-aae2cd32#_2-2-前缀操作\",\"88\":\"v-aae2cd32#_3-其他形式的前缀和\",\"89\":\"v-aae2cd32#_3-1-二维前缀和\",\"90\":\"v-aae2cd32#_3-2-高维前缀和\",\"91\":\"v-aae2cd32#_3-3-树形前缀和\",\"92\":\"v-aae2cd32#_5-标准库实现\",\"93\":\"v-e4d6f294\",\"94\":\"v-7aab689f\",\"95\":\"v-7aab689f#_1-c-数组初始化\",\"96\":\"v-7aab689f#_2-python-数组初始化\",\"97\":\"v-56b80a9c\",\"98\":\"v-56b80a9c#_1-缩略词\",\"99\":\"v-2ac76582\",\"100\":\"v-2942cd58\",\"101\":\"v-2942cd58#_1-c-i-o-优化\",\"102\":\"v-0e781205\",\"103\":\"v-0e781205#_1-数组的定义\",\"104\":\"v-0e781205#_2-c-数组\",\"105\":\"v-0e781205#_3-python-数组\",\"106\":\"v-0e781205#_3-1-低层次数组\",\"107\":\"v-0e781205#_3-2-使用紧凑数组\",\"108\":\"v-0e781205#_3-3-动态数组\",\"109\":\"v-807743b6\",\"110\":\"v-807743b6#目录\",\"111\":\"v-5a15346c\",\"112\":\"v-6d6e4366\",\"113\":\"v-5fc0f194\",\"114\":\"v-ed464c86\",\"115\":\"v-4cb706d2\",\"116\":\"v-4cb706d2#_1-非公平组合游戏\",\"117\":\"v-4cb706d2#_2-公平组合游戏\",\"118\":\"v-4cb706d2#_3-反常游戏\",\"119\":\"v-4cb706d2#_4-常见的公平组合游戏\",\"120\":\"v-4cb706d2#_4-1-简化的-nim-博弈-nim-game\",\"121\":\"v-4cb706d2#_4-2-除数博弈-divisor-game\",\"122\":\"v-4cb706d2#_4-3-巴什博奕-bash-game\",\"123\":\"v-4cb706d2#_4-4-威佐夫博弈-wythoff-game\",\"124\":\"v-4cb706d2#_4-5-nim-博弈-nim-game\",\"125\":\"v-1b4ab288\",\"126\":\"v-7f8f5394\",\"127\":\"v-7f8f5394#_1-局面和其性质\",\"128\":\"v-7f8f5394#_2-sg-函数\",\"129\":\"v-7f8f5394#_3-一般求解步骤\",\"130\":\"v-7f8f5394#_4-sg-定理\",\"131\":\"v-7f8f5394#_5-例题\",\"132\":\"v-7f8f5394#_5-1-fibonacci-again-and-again-hdu1848\",\"133\":\"v-30f43012\",\"134\":\"v-30f43012#_1-图的定义\",\"135\":\"v-30f43012#_1-2-基本概念\",\"136\":\"v-30f43012#_2-图的存储结构\",\"137\":\"v-30f43012#_2-1-邻接矩阵存储\",\"138\":\"v-30f43012#_2-2-邻接表储存\",\"139\":\"v-30f43012#_3-图的遍历\",\"140\":\"v-30f43012#_3-1-深度优先遍历\",\"141\":\"v-30f43012#_3-2-广度优先遍历\",\"142\":\"v-30f43012#_3-3-一笔画问题\",\"143\":\"v-30f43012#_3-4-哈密尔顿回路\",\"144\":\"v-2c6e30b0\",\"145\":\"v-2c6e30b0#_1-同余的定义\",\"146\":\"v-2c6e30b0#_2-同余的性质\",\"147\":\"v-2c6e30b0#_2-1-常用性质\",\"148\":\"v-2c6e30b0#_2-2-费尔马小定理\",\"149\":\"v-2c6e30b0#_3-剩余类和完全剩余系\",\"150\":\"v-2c6e30b0#_3-1-剩余类定义\",\"151\":\"v-2c6e30b0#_3-2-剩余类性质\",\"152\":\"v-2c6e30b0#_3-3-完全剩余系\",\"153\":\"v-2c6e30b0#_4-不定方程\",\"154\":\"v-2c6e30b0#_5-孙子定理\",\"155\":\"v-76278df8\",\"156\":\"v-76278df8#_1-多边形数\",\"157\":\"v-76278df8#_2-费马多边形定理\",\"158\":\"v-76278df8#_3-四平方和定理\",\"159\":\"v-76278df8#_4-完全平方和问题\",\"160\":\"v-76278df8#_4-1-四平方和定理解答\",\"161\":\"v-76278df8#_4-2-动态规划\",\"162\":\"v-76278df8#_5-费马平方和定理\",\"163\":\"v-6983b586\",\"164\":\"v-6983b586#_1-最大公约数定义\",\"165\":\"v-6983b586#_2-欧几里得算法\",\"166\":\"v-6983b586#_2-1-递归法\",\"167\":\"v-6983b586#_2-2-快速实现\",\"168\":\"v-6983b586#_3-stein-算法\",\"169\":\"v-6983b586#_4-扩展欧几里得算法\",\"170\":\"v-6983b586#_5-最小公倍数\",\"171\":\"v-6983b586#_3-标准库实现\",\"172\":\"v-310afec2\",\"173\":\"v-0051b9bc\",\"174\":\"v-0051b9bc#_1-暴力筛法\",\"175\":\"v-0051b9bc#_2-埃拉托斯特尼筛法\",\"176\":\"v-0051b9bc#_2-欧拉筛法\",\"177\":\"v-5cb727fa\",\"178\":\"v-5cb727fa#_1-dijkstra-算法\",\"179\":\"v-5cb727fa#_2-a-算法\",\"180\":\"v-5cb727fa#_3-d-算法\",\"181\":\"v-5cb727fa#_4-lpa-算法\",\"182\":\"v-5cb727fa#_5-d-lite-算法\",\"183\":\"v-5cb727fa#总结\",\"184\":\"v-9403fcc8\",\"185\":\"v-03a27c45\",\"186\":\"v-6d9f9369\",\"187\":\"v-6d9f9369#_1-拒绝采样的定义\",\"188\":\"v-6d9f9369#_2-例题\",\"189\":\"v-6d9f9369#_2-1-用-rand7-实现-rand10\",\"190\":\"v-85a62f2a\",\"191\":\"v-85a62f2a#_1-柯西不等式表述\",\"192\":\"v-85a62f2a#_2-重要结论\",\"193\":\"v-85a62f2a#附录-构造函数证明柯西不等式\",\"194\":\"v-05030461\",\"195\":\"v-13d802f3\",\"196\":\"v-13d802f3#_1-基本不等式\",\"197\":\"v-13d802f3#_2-平均数\",\"198\":\"v-13d802f3#_3-均值不等式\",\"199\":\"v-13d802f3#附录-结论推广\",\"200\":\"v-0ea405e8\",\"201\":\"v-0ea405e8#_1-等差数列定义\",\"202\":\"v-0ea405e8#_2-等差数列的性质\",\"203\":\"v-373d6f8e\",\"204\":\"v-09c96424\",\"205\":\"v-09c96424#_1-数列的定义\",\"206\":\"v-09c96424#_2-数列的常见性质\",\"207\":\"v-09c96424#_2-1-单调性\",\"208\":\"v-09c96424#_2-2-有限性\",\"209\":\"v-09c96424#_2-3-有界性\",\"210\":\"v-09c96424#_2-4-收敛性\",\"211\":\"v-09c96424#_2-5-周期性\",\"212\":\"v-09c96424#_3-常见的数列\",\"213\":\"v-09c96424#_3-1-等差数列\",\"214\":\"v-09c96424#_3-2-等比数列\",\"215\":\"v-09c96424#_3-3-等和数列\",\"216\":\"v-b36a4586\",\"217\":\"v-b36a4586#_1-集合的划分\",\"218\":\"v-b36a4586#_2-容斥公式\",\"219\":\"v-b36a4586#_3-筛法公式\",\"220\":\"v-2e3b5af0\",\"221\":\"v-24115ca7\",\"222\":\"v-24115ca7#_1-集合\",\"223\":\"v-24115ca7#_1-1-集合的定义\",\"224\":\"v-24115ca7#_1-2-集合的表示\",\"225\":\"v-24115ca7#_1-3-常见的集合\",\"226\":\"v-24115ca7#_2-区间\",\"227\":\"v-24115ca7#_3-集合的运算\",\"228\":\"v-24115ca7#_4-集合运算的性质\",\"229\":\"v-24115ca7#_4-1-基础结论\",\"230\":\"v-24115ca7#_4-2-运算性质\",\"231\":\"v-35b1da17\",\"232\":\"v-35b1da17#_1-1-什么是编译\",\"233\":\"v-35b1da17#_1-1-1-计算机程序设计语言及编译\",\"234\":\"v-35b1da17#_1-1-2-编译器在语言处理系统中的位置\",\"235\":\"v-35b1da17#_1-2-编译系统的结构\",\"236\":\"v-35b1da17#_1-2-1-人工英汉翻译的例子\",\"237\":\"v-35b1da17#_1-2-2-编译器的结构\",\"238\":\"v-35b1da17#_1-3-词法分析概述\",\"239\":\"v-35b1da17#_1-3-1-词法分析的主要任务\",\"240\":\"v-35b1da17#_1-3-2-词法分析后得到的-token-序列\",\"241\":\"v-35b1da17#_1-4-语法分析概述\",\"242\":\"v-35b1da17#_1-4-1-语法分析器\",\"243\":\"v-35b1da17#_1-4-2-赋值语句分析树\",\"244\":\"v-35b1da17#_1-4-3-变量声明语句的分析树\",\"245\":\"v-35b1da17#_1-5-语义分析概述\",\"246\":\"v-35b1da17#_1-5-1-语义分析的主要任务\",\"247\":\"v-35b1da17#_1-5-2-收集标识符的属性信息\",\"248\":\"v-35b1da17#_1-5-3-语义检查\",\"249\":\"v-35b1da17#_1-6-中间代码生成和编译器后端\",\"250\":\"v-35b1da17#_1-6-1-常用的中间表示形式\",\"251\":\"v-35b1da17#_1-6-2-中间代码生成的例子\",\"252\":\"v-35b1da17#_1-6-3-目标代码生成\",\"253\":\"v-35b1da36\",\"254\":\"v-35b1da36#_2-1-词法语法分析基本概念\",\"255\":\"v-35b1da36#_2-1-1-字母表\",\"256\":\"v-35b1da36#_2-1-2-字母表上的运算\",\"257\":\"v-35b1da36#_2-1-3-串上的运算\",\"258\":\"v-35b1da36#_2-2-文法定义\",\"259\":\"v-35b1da36#_2-2-1-文法的定义\",\"260\":\"v-35b1da36#_2-2-2-简化后的算数表达式的文法\",\"261\":\"v-35b1da36#_2-2-3-产生式的简写\",\"262\":\"v-35b1da36#_2-2-4-符号约定\",\"263\":\"v-35b1da36#_2-3-语言的定义\",\"264\":\"v-35b1da36#_2-3-1-推导和归约\",\"265\":\"v-35b1da36#_2-3-2-句型和句子\",\"266\":\"v-35b1da36#_2-3-3-练习-写出无符号整数和浮点数的文法\",\"267\":\"v-35b1da36#_2-3-4-语言上的运算\",\"268\":\"v-35b1da36#_2-4-文法的分类\",\"269\":\"v-35b1da36#_2-4-1-chomsky-文法分类体系\",\"270\":\"v-35b1da36#_2-4-2-四种文法的关系\",\"271\":\"v-35b1da36#_2-5-cfg-的分析树\",\"272\":\"v-35b1da36#_2-5-1-举例分析\",\"273\":\"v-35b1da36#_2-5-2-分析树推导的图形化表示\",\"274\":\"v-35b1da36#_2-5-3-句型的短语\",\"275\":\"v-35b1da36#_2-5-4-二义性文法\",\"276\":\"v-35b1da36#_2-5-5-二义性文法的判定\",\"277\":\"v-35b1da55\",\"278\":\"v-35b1da55#_3-1-正则表达式\",\"279\":\"v-35b1da55#_3-1-1-正则表达式定义\",\"280\":\"v-35b1da55#_3-1-2-正则表达式与正则文法是等价的\",\"281\":\"v-35b1da55#_3-2-正则定义\",\"282\":\"v-35b1da55#_3-2-1-什么是正则定义\",\"283\":\"v-35b1da55#_3-2-2-c-语言标识符的正则定义\",\"284\":\"v-35b1da55#_3-3-有穷自动机\",\"285\":\"v-35b1da55#_3-3-1-有穷自动机定义\",\"286\":\"v-35b1da55#_3-3-2-fa-的典型例子\",\"287\":\"v-35b1da55#_3-3-3-fa-接收的语言\",\"288\":\"v-35b1da55#_3-4-有穷自动机的分类\",\"289\":\"v-35b1da55#_3-4-1-确定的有穷自动机-dfa\",\"290\":\"v-35b1da55#_3-4-2-非确定的有穷自动机-nfa\",\"291\":\"v-35b1da55#_3-4-3-dfa-和-nfa-的等价性\",\"292\":\"v-35b1da55#_3-4-4-带-ε-边-的-nfa\",\"293\":\"v-35b1da55#_3-4-5-dfa-算法实现\",\"294\":\"v-35b1da55#_3-5-从正则表达式到有穷自动机\",\"295\":\"v-35b1da55#_3-5-1-构造方法\",\"296\":\"v-35b1da55#_3-5-2-根据-re-构造-nfa\",\"297\":\"v-35b1da55#_3-6-从-nfa-到-dfa-的转换\",\"298\":\"v-35b1da55#_3-6-1-转换示例\",\"299\":\"v-35b1da55#_3-6-2-带有空边的-nfa-到-dfa\",\"300\":\"v-35b1da55#_3-6-3-子集构造法-subset-construction\",\"301\":\"v-35b1da55#_3-6-4-计算\",\"302\":\"v-35b1da55#_3-7-识别单词的-dfa\",\"303\":\"v-35b1da55#_3-7-1-定义\",\"304\":\"v-35b1da55#_3-7-2-识别注释的-dfa\",\"305\":\"v-35b1da55#_3-7-3-识别-token-的-dfa\",\"306\":\"v-35b1da55#_3-7-4-词法分析阶段中的错误处理\",\"307\":\"v-6ca493b2\",\"308\":\"v-087c593e\",\"309\":\"v-6dbdbc85\",\"310\":\"v-6dbdbc85#_1-集合的定义\",\"311\":\"v-6dbdbc85#_2-集合-adt\",\"312\":\"v-6bfacb0a\",\"313\":\"v-2801b14c\",\"314\":\"v-d55937a2\",\"315\":\"v-d55937a2#_1-基础概念\",\"316\":\"v-d55937a2#_1-1-无根树\",\"317\":\"v-d55937a2#_1-2-有根树\",\"318\":\"v-d55937a2#_1-3-二叉树的性质\",\"319\":\"v-d55937a2#_2-树的储存结构\",\"320\":\"v-d55937a2#_2-1-父结点表示法\",\"321\":\"v-d55937a2#_2-2-子结点表示法\",\"322\":\"v-d55937a2#_2-3-父亲孩子表示法\",\"323\":\"v-d55937a2#_2-4-孩子兄弟表示法\",\"324\":\"v-58e45a54\",\"325\":\"v-58e45a54#_1-字典树的定义\",\"326\":\"v-ac98ccb0\",\"327\":\"v-ac98ccb0#_1-0-1-背包理论\",\"328\":\"v-ac98ccb0#_2-基本思路\",\"329\":\"v-ac98ccb0#_3-滚动数组\",\"330\":\"v-ac98ccb0#_4-模板总结\",\"331\":\"v-ac98ccb0#_5-获取背包的内容\",\"332\":\"v-ac98ccb0#附录-背包与贪心问题\",\"333\":\"v-6e9acf86\",\"334\":\"v-6e9acf86#_1-完全背包定义\",\"335\":\"v-6e9acf86#_2-模板总结\",\"336\":\"v-6e9acf86#_3-获取完全背包内的物品\",\"337\":\"v-94823b10\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1],\"2\":[1],\"3\":[2],\"4\":[2],\"5\":[1],\"6\":[2],\"7\":[2],\"8\":[2],\"9\":[3],\"10\":[1],\"11\":[1],\"12\":[2],\"13\":[2],\"14\":[1],\"15\":[1],\"16\":[1],\"17\":[2],\"18\":[2],\"19\":[2],\"20\":[2],\"21\":[3],\"22\":[3],\"23\":[2],\"24\":[1],\"25\":[2],\"26\":[2],\"27\":[3],\"28\":[2],\"29\":[3],\"30\":[2],\"31\":[1],\"32\":[2],\"33\":[2],\"34\":[2],\"35\":[1],\"36\":[2],\"37\":[1],\"38\":[2],\"39\":[1],\"40\":[1],\"41\":[2],\"42\":[1],\"43\":[2],\"44\":[2],\"45\":[2],\"46\":[5],\"47\":[4],\"48\":[2],\"49\":[2],\"50\":[2],\"51\":[2],\"52\":[1],\"53\":[2],\"54\":[2],\"55\":[2],\"56\":[3],\"57\":[3],\"58\":[2],\"59\":[3],\"60\":[3],\"61\":[3],\"62\":[3],\"63\":[3],\"64\":[2],\"65\":[3],\"66\":[3],\"67\":[3],\"68\":[2],\"69\":[5],\"70\":[3],\"71\":[3],\"72\":[1],\"73\":[2],\"74\":[2],\"75\":[1],\"76\":[2],\"77\":[2],\"78\":[3],\"79\":[2],\"80\":[2],\"81\":[2],\"82\":[1],\"83\":[1],\"84\":[2],\"85\":[2],\"86\":[3],\"87\":[2],\"88\":[2],\"89\":[3],\"90\":[3],\"91\":[2],\"92\":[2],\"93\":[1],\"94\":[1],\"95\":[3],\"96\":[3],\"97\":[1],\"98\":[2],\"99\":[1],\"100\":[3],\"101\":[5],\"102\":[1],\"103\":[2],\"104\":[3],\"105\":[3],\"106\":[3],\"107\":[3],\"108\":[2],\"109\":[1],\"110\":[1],\"111\":[1],\"112\":[1],\"113\":[1],\"114\":[1],\"115\":[1],\"116\":[2],\"117\":[2],\"118\":[2],\"119\":[2],\"120\":[7],\"121\":[6],\"122\":[6],\"123\":[5],\"124\":[6],\"125\":[1],\"126\":[2],\"127\":[2],\"128\":[3],\"129\":[2],\"130\":[3],\"131\":[2],\"132\":[7],\"133\":[1],\"134\":[2],\"135\":[3],\"136\":[2],\"137\":[3],\"138\":[2],\"139\":[2],\"140\":[3],\"141\":[3],\"142\":[2],\"143\":[3],\"144\":[1],\"145\":[2],\"146\":[2],\"147\":[3],\"148\":[2],\"149\":[2],\"150\":[3],\"151\":[3],\"152\":[2],\"153\":[2],\"154\":[2],\"155\":[1],\"156\":[2],\"157\":[2],\"158\":[2],\"159\":[2],\"160\":[3],\"161\":[3],\"162\":[2],\"163\":[1],\"164\":[2],\"165\":[2],\"166\":[3],\"167\":[2],\"168\":[3],\"169\":[2],\"170\":[2],\"171\":[2],\"172\":[1],\"173\":[1],\"174\":[2],\"175\":[2],\"176\":[2],\"177\":[1],\"178\":[3],\"179\":[3],\"180\":[3],\"181\":[3],\"182\":[4],\"183\":[1],\"184\":[1],\"185\":[1],\"186\":[1],\"187\":[2],\"188\":[2],\"189\":[6],\"190\":[1],\"191\":[2],\"192\":[2],\"193\":[2],\"194\":[1],\"195\":[1],\"196\":[2],\"197\":[2],\"198\":[2],\"199\":[2],\"200\":[1],\"201\":[2],\"202\":[2],\"203\":[1],\"204\":[1],\"205\":[2],\"206\":[2],\"207\":[3],\"208\":[2],\"209\":[3],\"210\":[3],\"211\":[3],\"212\":[2],\"213\":[3],\"214\":[3],\"215\":[2],\"216\":[1],\"217\":[2],\"218\":[2],\"219\":[2],\"220\":[1],\"221\":[1],\"222\":[2],\"223\":[2],\"224\":[3],\"225\":[3],\"226\":[2],\"227\":[2],\"228\":[2],\"229\":[3],\"230\":[3],\"231\":[2],\"232\":[2],\"233\":[2],\"234\":[3],\"235\":[3],\"236\":[3],\"237\":[3],\"238\":[3],\"239\":[3],\"240\":[6],\"241\":[3],\"242\":[3],\"243\":[4],\"244\":[4],\"245\":[3],\"246\":[3],\"247\":[4],\"248\":[4],\"249\":[3],\"250\":[3],\"251\":[4],\"252\":[4],\"253\":[2],\"254\":[3],\"255\":[3],\"256\":[3],\"257\":[4],\"258\":[2],\"259\":[3],\"260\":[2],\"261\":[3],\"262\":[3],\"263\":[3],\"264\":[4],\"265\":[3],\"266\":[4],\"267\":[4],\"268\":[3],\"269\":[5],\"270\":[3],\"271\":[4],\"272\":[4],\"273\":[3],\"274\":[4],\"275\":[4],\"276\":[3],\"277\":[2],\"278\":[3],\"279\":[3],\"280\":[4],\"281\":[3],\"282\":[4],\"283\":[4],\"284\":[2],\"285\":[3],\"286\":[4],\"287\":[3],\"288\":[3],\"289\":[6],\"290\":[6],\"291\":[6],\"292\":[7],\"293\":[5],\"294\":[3],\"295\":[4],\"296\":[7],\"297\":[7],\"298\":[4],\"299\":[7],\"300\":[6],\"301\":[17],\"302\":[4],\"303\":[4],\"304\":[5],\"305\":[6],\"306\":[4],\"307\":[1],\"308\":[3],\"309\":[2],\"310\":[2],\"311\":[3],\"312\":[1],\"313\":[1],\"314\":[1],\"315\":[2],\"316\":[2],\"317\":[3],\"318\":[3],\"319\":[2],\"320\":[3],\"321\":[2],\"322\":[3],\"323\":[3],\"324\":[1],\"325\":[2],\"326\":[3],\"327\":[3],\"328\":[2],\"329\":[2],\"330\":[2],\"331\":[2],\"332\":[2],\"333\":[1],\"334\":[2],\"335\":[2],\"336\":[2],\"337\":[1]},\"averageFieldLength\":[2.56508875739645],\"storedFields\":{\"0\":{\"h\":\"算法和数据结构笔记\"},\"1\":{\"h\":\"相关领域\"},\"2\":{\"h\":\"算法分析\"},\"3\":{\"h\":\"1. 算法分析的目标\"},\"4\":{\"h\":\"2. 实验结果\"},\"5\":{\"h\":\"算法\"},\"6\":{\"h\":\"1. 算法的基本概念\"},\"7\":{\"h\":\"2. 伪代码编写\"},\"8\":{\"h\":\"3. 算法的数学基础\"},\"9\":{\"h\":\"3.1 函数的渐进的界\"},\"10\":{\"h\":\"算法分析\"},\"11\":{\"h\":\"斯特林公式\"},\"12\":{\"h\":\"1. 数学表示\"},\"13\":{\"h\":\"2. 斯特林近似\"},\"14\":{\"h\":\"平衡三进制\"},\"15\":{\"h\":\"基础数学知识\"},\"16\":{\"h\":\"数学符号定义\"},\"17\":{\"h\":\"1. 公式和字体\"},\"18\":{\"h\":\"2. 基本\"},\"19\":{\"h\":\"3. 证明中的符号\"},\"20\":{\"h\":\"4. 大型运算符\"},\"21\":{\"h\":\"4.1 求和\"},\"22\":{\"h\":\"4.2 求积\"},\"23\":{\"h\":\"5. 数论\"},\"24\":{\"h\":\"排列组合\"},\"25\":{\"h\":\"1. 计数原理\"},\"26\":{\"h\":\"1.1 加法原理\"},\"27\":{\"h\":\"1.2 乘法原理\"},\"28\":{\"h\":\"2. 排列组合基础\"},\"29\":{\"h\":\"2.1 排列数\"},\"30\":{\"h\":\"2.2. 组合\"},\"31\":{\"h\":\"组合恒等式\"},\"32\":{\"h\":\"1. 生成函数\"},\"33\":{\"h\":\"2. 常见的组合性质\"},\"34\":{\"h\":\"附录：组合的有趣性质\"},\"35\":{\"h\":\"斐波那契数和组合数\"},\"36\":{\"h\":\"n n n 维空间和组合数\"},\"37\":{\"h\":\"斐波那契数列\"},\"38\":{\"h\":\"1. 定义\"},\"39\":{\"h\":\"组合数学\"},\"40\":{\"h\":\"斯特林数\"},\"41\":{\"h\":\"1. 第一类斯特林数\"},\"42\":{\"h\":\"二分算法\"},\"43\":{\"h\":\"1. 二分查找\"},\"44\":{\"h\":\"2. 代码实现\"},\"45\":{\"h\":\"3. 标准库实现\"},\"46\":{\"h\":\"3.1 C++ STL 实现\"},\"47\":{\"h\":\"3.2 C 语言\"},\"48\":{\"h\":\"3.3 Python\"},\"49\":{\"h\":\"4. 二分答案\"},\"50\":{\"h\":\"5. 分数规划\"},\"51\":{\"h\":\"6. 三分法\"},\"52\":{\"h\":\"位运算\"},\"53\":{\"h\":\"1. 位运算的功能\"},\"54\":{\"h\":\"2. 位运算优先级\"},\"55\":{\"h\":\"3. 位运算详解\"},\"56\":{\"h\":\"3.1 按位与\"},\"57\":{\"h\":\"3.2 按位或\"},\"58\":{\"h\":\"3.3 异或\"},\"59\":{\"h\":\"3.4 按位取反\"},\"60\":{\"h\":\"3.5 左移\"},\"61\":{\"h\":\"3.6 右移\"},\"62\":{\"h\":\"3.7 无符号右移\"},\"63\":{\"h\":\"3.8 公式总结\"},\"64\":{\"h\":\"4. 位运算总结\"},\"65\":{\"h\":\"4.1 交换两个数\"},\"66\":{\"h\":\"4.2 快速最小公倍数\"},\"67\":{\"h\":\"4.3 判断奇偶\"},\"68\":{\"h\":\"4.4 符号相同\"},\"69\":{\"h\":\"4.5 第 i+1 位\"},\"70\":{\"h\":\"4.6 最低有效位\"},\"71\":{\"h\":\"4.7 绝对值\"},\"72\":{\"h\":\"差分数组\"},\"73\":{\"h\":\"1. 差分数组的定义\"},\"74\":{\"h\":\"2. 性质\"},\"75\":{\"h\":\"快速幂\"},\"76\":{\"h\":\"1. 快速幂算法\"},\"77\":{\"h\":\"1.1 递归版本\"},\"78\":{\"h\":\"1.2 非递归版本\"},\"79\":{\"h\":\"2. 模意义下取幂\"},\"80\":{\"h\":\"3. 斐波那契数列\"},\"81\":{\"h\":\"4. 求矩阵的快速幂\"},\"82\":{\"h\":\"常见算法\"},\"83\":{\"h\":\"前缀和\"},\"84\":{\"h\":\"1. 前缀和定义\"},\"85\":{\"h\":\"2. 前缀和的推广\"},\"86\":{\"h\":\"2.1 后缀和\"},\"87\":{\"h\":\"2.2 前缀操作\"},\"88\":{\"h\":\"3. 其他形式的前缀和\"},\"89\":{\"h\":\"3.1 二维前缀和\"},\"90\":{\"h\":\"3.2 高维前缀和\"},\"91\":{\"h\":\"3.3 树形前缀和\"},\"92\":{\"h\":\"5. 标准库实现\"},\"93\":{\"h\":\"编译原理\"},\"94\":{\"h\":\"数组优化\"},\"95\":{\"h\":\"1. C++ 数组初始化\"},\"96\":{\"h\":\"2. Python 数组初始化\"},\"97\":{\"h\":\"术语表\"},\"98\":{\"h\":\"1. 缩略词\"},\"99\":{\"h\":\"竞赛指南\"},\"100\":{\"h\":\"I/O 优化\"},\"101\":{\"h\":\"1. C++ I/O 优化\"},\"102\":{\"h\":\"数组\"},\"103\":{\"h\":\"1. 数组的定义\"},\"104\":{\"h\":\"2. C++ 数组\"},\"105\":{\"h\":\"3. Python 数组\"},\"106\":{\"h\":\"3.1 低层次数组\"},\"107\":{\"h\":\"3.2 使用紧凑数组\"},\"108\":{\"h\":\"3.3 动态数组\"},\"109\":{\"h\":\"基础数据结构\"},\"110\":{\"h\":\"目录\"},\"111\":{\"h\":\"链表\"},\"112\":{\"h\":\"队列\"},\"113\":{\"h\":\"栈\"},\"114\":{\"h\":\"动态规划\"},\"115\":{\"h\":\"博弈论简介\"},\"116\":{\"h\":\"1. 非公平组合游戏\"},\"117\":{\"h\":\"2. 公平组合游戏\"},\"118\":{\"h\":\"3. 反常游戏\"},\"119\":{\"h\":\"4. 常见的公平组合游戏\"},\"120\":{\"h\":\"4.1 简化的 Nim 博弈（Nim Game）\"},\"121\":{\"h\":\"4.2 除数博弈（Divisor Game）\"},\"122\":{\"h\":\"4.3 巴什博奕（Bash Game）\"},\"123\":{\"h\":\"4.4 威佐夫博弈（Wythoff Game）\"},\"124\":{\"h\":\"4.5 Nim 博弈（Nim Game）\"},\"125\":{\"h\":\"博弈论\"},\"126\":{\"h\":\"SG 定理\"},\"127\":{\"h\":\"1. 局面和其性质\"},\"128\":{\"h\":\"2. SG 函数\"},\"129\":{\"h\":\"3. 一般求解步骤\"},\"130\":{\"h\":\"4. SG 定理\"},\"131\":{\"h\":\"5. 例题\"},\"132\":{\"h\":\"5.1 Fibonacci again and again(HDU1848)\"},\"133\":{\"h\":\"图论\"},\"134\":{\"h\":\"1. 图的定义\"},\"135\":{\"h\":\"1.2 基本概念\"},\"136\":{\"h\":\"2. 图的存储结构\"},\"137\":{\"h\":\"2.1 邻接矩阵存储\"},\"138\":{\"h\":\"2.2 邻接表储存\"},\"139\":{\"h\":\"3. 图的遍历\"},\"140\":{\"h\":\"3.1 深度优先遍历\"},\"141\":{\"h\":\"3.2 广度优先遍历\"},\"142\":{\"h\":\"3.3 一笔画问题\"},\"143\":{\"h\":\"3.4 哈密尔顿回路\"},\"144\":{\"h\":\"同余\"},\"145\":{\"h\":\"1. 同余的定义\"},\"146\":{\"h\":\"2. 同余的性质\"},\"147\":{\"h\":\"2.1 常用性质\"},\"148\":{\"h\":\"2.2 费尔马小定理\"},\"149\":{\"h\":\"3. 剩余类和完全剩余系\"},\"150\":{\"h\":\"3.1 剩余类定义\"},\"151\":{\"h\":\"3.2 剩余类性质\"},\"152\":{\"h\":\"3.3 完全剩余系\"},\"153\":{\"h\":\"4. 不定方程\"},\"154\":{\"h\":\"5. 孙子定理\"},\"155\":{\"h\":\"费马多边形定理\"},\"156\":{\"h\":\"1. 多边形数\"},\"157\":{\"h\":\"2. 费马多边形定理\"},\"158\":{\"h\":\"3. 四平方和定理\"},\"159\":{\"h\":\"4. 完全平方和问题\"},\"160\":{\"h\":\"4.1 四平方和定理解答\"},\"161\":{\"h\":\"4.2 动态规划\"},\"162\":{\"h\":\"5. 费马平方和定理\"},\"163\":{\"h\":\"最大公约数与最小公倍数\"},\"164\":{\"h\":\"1. 最大公约数定义\"},\"165\":{\"h\":\"2. 欧几里得算法\"},\"166\":{\"h\":\"2.1 递归法\"},\"167\":{\"h\":\"2.2 快速实现\"},\"168\":{\"h\":\"3. Stein 算法\"},\"169\":{\"h\":\"4. 扩展欧几里得算法\"},\"170\":{\"h\":\"5. 最小公倍数\"},\"171\":{\"h\":\"3. 标准库实现\"},\"172\":{\"h\":\"数论\"},\"173\":{\"h\":\"素数筛法\"},\"174\":{\"h\":\"1. 暴力筛法\"},\"175\":{\"h\":\"2. 埃拉托斯特尼筛法\"},\"176\":{\"h\":\"2. 欧拉筛法\"},\"177\":{\"h\":\"路径规划算法\"},\"178\":{\"h\":\"1. Dijkstra 算法\"},\"179\":{\"h\":\"2. A* 算法\"},\"180\":{\"h\":\"3. D* 算法\"},\"181\":{\"h\":\"4. LPA* 算法\"},\"182\":{\"h\":\"5. D* lite 算法\"},\"183\":{\"h\":\"总结\"},\"184\":{\"h\":\"二项分布\"},\"185\":{\"h\":\"概率与统计\"},\"186\":{\"h\":\"拒绝采样\"},\"187\":{\"h\":\"1. 拒绝采样的定义\"},\"188\":{\"h\":\"2. 例题\"},\"189\":{\"h\":\"2.1 用 Rand7 实现 Rand10\"},\"190\":{\"h\":\"柯西不等式\"},\"191\":{\"h\":\"1. 柯西不等式表述\"},\"192\":{\"h\":\"2. 重要结论\"},\"193\":{\"h\":\"附录：构造函数证明柯西不等式\"},\"194\":{\"h\":\"不等式\"},\"195\":{\"h\":\"均值不等式\"},\"196\":{\"h\":\"1. 基本不等式\"},\"197\":{\"h\":\"2. 平均数\"},\"198\":{\"h\":\"3. 均值不等式\"},\"199\":{\"h\":\"附录：结论推广\"},\"200\":{\"h\":\"等差数列\"},\"201\":{\"h\":\"1. 等差数列定义\"},\"202\":{\"h\":\"2. 等差数列的性质\"},\"203\":{\"h\":\"数列\"},\"204\":{\"h\":\"数列简介\"},\"205\":{\"h\":\"1. 数列的定义\"},\"206\":{\"h\":\"2. 数列的常见性质\"},\"207\":{\"h\":\"2.1 单调性\"},\"208\":{\"h\":\"2.2 有限性\"},\"209\":{\"h\":\"2.3 有界性\"},\"210\":{\"h\":\"2.4 收敛性\"},\"211\":{\"h\":\"2.5 周期性\"},\"212\":{\"h\":\"3. 常见的数列\"},\"213\":{\"h\":\"3.1 等差数列\"},\"214\":{\"h\":\"3.2 等比数列\"},\"215\":{\"h\":\"3.3 等和数列\"},\"216\":{\"h\":\"容斥原理\"},\"217\":{\"h\":\"1. 集合的划分\"},\"218\":{\"h\":\"2. 容斥公式\"},\"219\":{\"h\":\"3. 筛法公式\"},\"220\":{\"h\":\"集合论\"},\"221\":{\"h\":\"集合\"},\"222\":{\"h\":\"1. 集合\"},\"223\":{\"h\":\"1.1 集合的定义\"},\"224\":{\"h\":\"1.2 集合的表示\"},\"225\":{\"h\":\"1.3 常见的集合\"},\"226\":{\"h\":\"2. 区间\"},\"227\":{\"h\":\"3. 集合的运算\"},\"228\":{\"h\":\"4. 集合运算的性质\"},\"229\":{\"h\":\"4.1 基础结论\"},\"230\":{\"h\":\"4.2 运算性质\"},\"231\":{\"h\":\"1. 绪论\"},\"232\":{\"h\":\"1.1 什么是编译\"},\"233\":{\"h\":\"1.1.1 计算机程序设计语言及编译\"},\"234\":{\"h\":\"1.1.2 编译器在语言处理系统中的位置\"},\"235\":{\"h\":\"1.2 编译系统的结构\"},\"236\":{\"h\":\"1.2.1 人工英汉翻译的例子\"},\"237\":{\"h\":\"1.2.2 编译器的结构\"},\"238\":{\"h\":\"1.3 词法分析概述\"},\"239\":{\"h\":\"1.3.1 词法分析的主要任务\"},\"240\":{\"h\":\"1.3.2 词法分析后得到的 token 序列\"},\"241\":{\"h\":\"1.4 语法分析概述\"},\"242\":{\"h\":\"1.4.1 语法分析器\"},\"243\":{\"h\":\"1.4.2 赋值语句分析树\"},\"244\":{\"h\":\"1.4.3 变量声明语句的分析树\"},\"245\":{\"h\":\"1.5 语义分析概述\"},\"246\":{\"h\":\"1.5.1 语义分析的主要任务\"},\"247\":{\"h\":\"1.5.2 收集标识符的属性信息\"},\"248\":{\"h\":\"1.5.3 语义检查\"},\"249\":{\"h\":\"1.6 中间代码生成和编译器后端\"},\"250\":{\"h\":\"1.6.1 常用的中间表示形式\"},\"251\":{\"h\":\"1.6.2 中间代码生成的例子\"},\"252\":{\"h\":\"1.6.3 目标代码生成\"},\"253\":{\"h\":\"2. 程序设计语言及其文法\"},\"254\":{\"h\":\"2.1 词法语法分析基本概念\"},\"255\":{\"h\":\"2.1.1 字母表\"},\"256\":{\"h\":\"2.1.2 字母表上的运算\"},\"257\":{\"h\":\"2.1.3 串上的运算\"},\"258\":{\"h\":\"2.2 文法定义\"},\"259\":{\"h\":\"2.2.1 文法的定义\"},\"260\":{\"h\":\"2.2.2 简化后的算数表达式的文法\"},\"261\":{\"h\":\"2.2.3 产生式的简写\"},\"262\":{\"h\":\"2.2.4 符号约定\"},\"263\":{\"h\":\"2.3 语言的定义\"},\"264\":{\"h\":\"2.3.1 推导和归约\"},\"265\":{\"h\":\"2.3.2 句型和句子\"},\"266\":{\"h\":\"2.3.3 练习：写出无符号整数和浮点数的文法\"},\"267\":{\"h\":\"2.3.4 语言上的运算\"},\"268\":{\"h\":\"2.4 文法的分类\"},\"269\":{\"h\":\"2.4.1 Chomsky 文法分类体系\"},\"270\":{\"h\":\"2.4.2 四种文法的关系\"},\"271\":{\"h\":\"2.5 CFG 的分析树\"},\"272\":{\"h\":\"2.5.1 举例分析\"},\"273\":{\"h\":\"2.5.2 分析树推导的图形化表示\"},\"274\":{\"h\":\"2.5.3 句型的短语\"},\"275\":{\"h\":\"2.5.4 二义性文法\"},\"276\":{\"h\":\"2.5.5 二义性文法的判定\"},\"277\":{\"h\":\"3. 词法分析\"},\"278\":{\"h\":\"3.1 正则表达式\"},\"279\":{\"h\":\"3.1.1 正则表达式定义\"},\"280\":{\"h\":\"3.1.2 正则表达式与正则文法是等价的\"},\"281\":{\"h\":\"3.2 正则定义\"},\"282\":{\"h\":\"3.2.1 什么是正则定义\"},\"283\":{\"h\":\"3.2.2 C 语言标识符的正则定义\"},\"284\":{\"h\":\"3.3 有穷自动机\"},\"285\":{\"h\":\"3.3.1 有穷自动机定义\"},\"286\":{\"h\":\"3.3.2 FA 的典型例子\"},\"287\":{\"h\":\"3.3.3 FA 接收的语言\"},\"288\":{\"h\":\"3.4 有穷自动机的分类\"},\"289\":{\"h\":\"3.4.1 确定的有穷自动机（DFA）\"},\"290\":{\"h\":\"3.4.2 非确定的有穷自动机（NFA）\"},\"291\":{\"h\":\"3.4.3 DFA 和 NFA 的等价性\"},\"292\":{\"h\":\"3.4.4 带 “ε-边” 的 NFA\"},\"293\":{\"h\":\"3.4.5 DFA 算法实现\"},\"294\":{\"h\":\"3.5 从正则表达式到有穷自动机\"},\"295\":{\"h\":\"3.5.1 构造方法\"},\"296\":{\"h\":\"3.5.2 根据 RE 构造 NFA\"},\"297\":{\"h\":\"3.6 从 NFA 到 DFA 的转换\"},\"298\":{\"h\":\"3.6.1 转换示例\"},\"299\":{\"h\":\"3.6.2 带有空边的 NFA 到 DFA\"},\"300\":{\"h\":\"3.6.3 子集构造法（Subset Construction）\"},\"301\":{\"h\":\"3.6.4 计算 ε _ c l o s u r e ( T ) \\\\mathrm{\\\\varepsilon\\\\_closure}(T) ε _closure ( T )\"},\"302\":{\"h\":\"3.7 识别单词的 DFA\"},\"303\":{\"h\":\"3.7.1 定义\"},\"304\":{\"h\":\"3.7.2 识别注释的 DFA\"},\"305\":{\"h\":\"3.7.3 识别 Token 的 DFA\"},\"306\":{\"h\":\"3.7.4 词法分析阶段中的错误处理\"},\"307\":{\"h\":\"集合\"},\"308\":{\"h\":\"给 JavaScript 读者的集合指南\"},\"309\":{\"h\":\"集合 ADT\"},\"310\":{\"h\":\"1. 集合的定义\"},\"311\":{\"h\":\"2. 集合 ADT\"},\"312\":{\"h\":\"二叉树\"},\"313\":{\"h\":\"树\"},\"314\":{\"h\":\"树\"},\"315\":{\"h\":\"1. 基础概念\"},\"316\":{\"h\":\"1.1 无根树\"},\"317\":{\"h\":\"1.2 有根树\"},\"318\":{\"h\":\"1.3 二叉树的性质\"},\"319\":{\"h\":\"2. 树的储存结构\"},\"320\":{\"h\":\"2.1 父结点表示法\"},\"321\":{\"h\":\"2.2 子结点表示法\"},\"322\":{\"h\":\"2.3 父亲孩子表示法\"},\"323\":{\"h\":\"2.4 孩子兄弟表示法\"},\"324\":{\"h\":\"字典树\"},\"325\":{\"h\":\"1. 字典树的定义\"},\"326\":{\"h\":\"0-1 背包\"},\"327\":{\"h\":\"1. 0-1 背包理论\"},\"328\":{\"h\":\"2. 基本思路\"},\"329\":{\"h\":\"3. 滚动数组\"},\"330\":{\"h\":\"4. 模板总结\"},\"331\":{\"h\":\"5. 获取背包的内容\"},\"332\":{\"h\":\"附录：背包与贪心问题\"},\"333\":{\"h\":\"完全背包\"},\"334\":{\"h\":\"1. 完全背包定义\"},\"335\":{\"h\":\"2. 模板总结\"},\"336\":{\"h\":\"3. 获取完全背包内的物品\"},\"337\":{\"h\":\"背包问题\"}},\"dirtCount\":0,\"index\":[[\"获取完全背包内的物品\",{\"0\":{\"336\":1}}],[\"获取背包的内容\",{\"0\":{\"331\":1}}],[\"模板总结\",{\"0\":{\"330\":1,\"335\":1}}],[\"模意义下取幂\",{\"0\":{\"79\":1}}],[\"滚动数组\",{\"0\":{\"329\":1}}],[\"背包问题\",{\"0\":{\"337\":1}}],[\"背包与贪心问题\",{\"0\":{\"332\":1}}],[\"背包理论\",{\"0\":{\"327\":1}}],[\"背包\",{\"0\":{\"326\":1}}],[\"0\",{\"0\":{\"326\":1,\"327\":1}}],[\"字典树的定义\",{\"0\":{\"325\":1}}],[\"字典树\",{\"0\":{\"324\":1}}],[\"字母表上的运算\",{\"0\":{\"256\":1}}],[\"字母表\",{\"0\":{\"255\":1}}],[\"孩子兄弟表示法\",{\"0\":{\"323\":1}}],[\"父亲孩子表示法\",{\"0\":{\"322\":1}}],[\"父结点表示法\",{\"0\":{\"320\":1}}],[\"子结点表示法\",{\"0\":{\"321\":1}}],[\"子集构造法\",{\"0\":{\"300\":1}}],[\"无根树\",{\"0\":{\"316\":1}}],[\"无符号右移\",{\"0\":{\"62\":1}}],[\"树的储存结构\",{\"0\":{\"319\":1}}],[\"树\",{\"0\":{\"313\":1,\"314\":1}}],[\"树形前缀和\",{\"0\":{\"91\":1}}],[\"读者的集合指南\",{\"0\":{\"308\":1}}],[\"javascript\",{\"0\":{\"308\":1}}],[\"给\",{\"0\":{\"308\":1}}],[\"识别\",{\"0\":{\"305\":1}}],[\"识别注释的\",{\"0\":{\"304\":1}}],[\"识别单词的\",{\"0\":{\"302\":1}}],[\"varepsilon\",{\"0\":{\"301\":1}}],[\"mathrm\",{\"0\":{\"301\":1}}],[\"t\",{\"0\":{\"301\":3}}],[\"token\",{\"0\":{\"240\":1,\"305\":1}}],[\"e\",{\"0\":{\"301\":1}}],[\"u\",{\"0\":{\"301\":1}}],[\"转换示例\",{\"0\":{\"298\":1}}],[\"到\",{\"0\":{\"297\":1,\"299\":1}}],[\"从\",{\"0\":{\"297\":1}}],[\"从正则表达式到有穷自动机\",{\"0\":{\"294\":1}}],[\"r\",{\"0\":{\"301\":1}}],[\"re\",{\"0\":{\"296\":1}}],[\"rand10\",{\"0\":{\"189\":1}}],[\"rand7\",{\"0\":{\"189\":1}}],[\"根据\",{\"0\":{\"296\":1}}],[\"构造\",{\"0\":{\"296\":1}}],[\"构造方法\",{\"0\":{\"295\":1}}],[\"构造函数证明柯西不等式\",{\"0\":{\"193\":1}}],[\"边\",{\"0\":{\"292\":1}}],[\"ε\",{\"0\":{\"292\":1,\"301\":2}}],[\"带有空边的\",{\"0\":{\"299\":1}}],[\"带\",{\"0\":{\"292\":1}}],[\"和\",{\"0\":{\"291\":1}}],[\"确定的有穷自动机\",{\"0\":{\"289\":1}}],[\"接收的语言\",{\"0\":{\"287\":1}}],[\"的转换\",{\"0\":{\"297\":1}}],[\"的\",{\"0\":{\"292\":1,\"305\":1}}],[\"的等价性\",{\"0\":{\"291\":1}}],[\"的典型例子\",{\"0\":{\"286\":1}}],[\"的分析树\",{\"0\":{\"271\":1}}],[\"fa\",{\"0\":{\"286\":1,\"287\":1}}],[\"fibonacci\",{\"0\":{\"132\":1}}],[\"什么是正则定义\",{\"0\":{\"282\":1}}],[\"什么是编译\",{\"0\":{\"232\":1}}],[\"正则定义\",{\"0\":{\"281\":1}}],[\"正则表达式与正则文法是等价的\",{\"0\":{\"280\":1}}],[\"正则表达式定义\",{\"0\":{\"279\":1}}],[\"正则表达式\",{\"0\":{\"278\":1}}],[\"句型的短语\",{\"0\":{\"274\":1}}],[\"句型和句子\",{\"0\":{\"265\":1}}],[\"分析树推导的图形化表示\",{\"0\":{\"273\":1}}],[\"分数规划\",{\"0\":{\"50\":1}}],[\"举例分析\",{\"0\":{\"272\":1}}],[\"四种文法的关系\",{\"0\":{\"270\":1}}],[\"四平方和定理解答\",{\"0\":{\"160\":1}}],[\"四平方和定理\",{\"0\":{\"158\":1}}],[\"写出无符号整数和浮点数的文法\",{\"0\":{\"266\":1}}],[\"练习\",{\"0\":{\"266\":1}}],[\"推导和归约\",{\"0\":{\"264\":1}}],[\"符号约定\",{\"0\":{\"262\":1}}],[\"符号相同\",{\"0\":{\"68\":1}}],[\"产生式的简写\",{\"0\":{\"261\":1}}],[\"简化后的算数表达式的文法\",{\"0\":{\"260\":1}}],[\"简化的\",{\"0\":{\"120\":1}}],[\"文法分类体系\",{\"0\":{\"269\":1}}],[\"文法的分类\",{\"0\":{\"268\":1}}],[\"文法的定义\",{\"0\":{\"259\":1}}],[\"文法定义\",{\"0\":{\"258\":1}}],[\"串上的运算\",{\"0\":{\"257\":1}}],[\"词法语法分析基本概念\",{\"0\":{\"254\":1}}],[\"词法分析阶段中的错误处理\",{\"0\":{\"306\":1}}],[\"词法分析\",{\"0\":{\"277\":1}}],[\"词法分析后得到的\",{\"0\":{\"240\":1}}],[\"词法分析的主要任务\",{\"0\":{\"239\":1}}],[\"词法分析概述\",{\"0\":{\"238\":1}}],[\"程序设计语言及其文法\",{\"0\":{\"253\":1}}],[\"目标代码生成\",{\"0\":{\"252\":1}}],[\"目录\",{\"0\":{\"110\":1}}],[\"中间代码生成的例子\",{\"0\":{\"251\":1}}],[\"中间代码生成和编译器后端\",{\"0\":{\"249\":1}}],[\"收集标识符的属性信息\",{\"0\":{\"247\":1}}],[\"收敛性\",{\"0\":{\"210\":1}}],[\"变量声明语句的分析树\",{\"0\":{\"244\":1}}],[\"赋值语句分析树\",{\"0\":{\"243\":1}}],[\"语义检查\",{\"0\":{\"248\":1}}],[\"语义分析的主要任务\",{\"0\":{\"246\":1}}],[\"语义分析概述\",{\"0\":{\"245\":1}}],[\"语法分析器\",{\"0\":{\"242\":1}}],[\"语法分析概述\",{\"0\":{\"241\":1}}],[\"语言标识符的正则定义\",{\"0\":{\"283\":1}}],[\"语言上的运算\",{\"0\":{\"267\":1}}],[\"语言的定义\",{\"0\":{\"263\":1}}],[\"语言\",{\"0\":{\"47\":1}}],[\"序列\",{\"0\":{\"240\":1}}],[\"人工英汉翻译的例子\",{\"0\":{\"236\":1}}],[\"编译器的结构\",{\"0\":{\"237\":1}}],[\"编译器在语言处理系统中的位置\",{\"0\":{\"234\":1}}],[\"编译系统的结构\",{\"0\":{\"235\":1}}],[\"编译原理\",{\"0\":{\"93\":1}}],[\"计算\",{\"0\":{\"301\":1}}],[\"计算机程序设计语言及编译\",{\"0\":{\"233\":1}}],[\"计数原理\",{\"0\":{\"25\":1}}],[\"绪论\",{\"0\":{\"231\":1}}],[\"运算性质\",{\"0\":{\"230\":1}}],[\"区间\",{\"0\":{\"226\":1}}],[\"集合运算的性质\",{\"0\":{\"228\":1}}],[\"集合的运算\",{\"0\":{\"227\":1}}],[\"集合的表示\",{\"0\":{\"224\":1}}],[\"集合的定义\",{\"0\":{\"223\":1,\"310\":1}}],[\"集合的划分\",{\"0\":{\"217\":1}}],[\"集合\",{\"0\":{\"221\":1,\"222\":1,\"307\":1,\"309\":1,\"311\":1}}],[\"集合论\",{\"0\":{\"220\":1}}],[\"筛法公式\",{\"0\":{\"219\":1}}],[\"容斥公式\",{\"0\":{\"218\":1}}],[\"容斥原理\",{\"0\":{\"216\":1}}],[\"等和数列\",{\"0\":{\"215\":1}}],[\"等比数列\",{\"0\":{\"214\":1}}],[\"等差数列的性质\",{\"0\":{\"202\":1}}],[\"等差数列定义\",{\"0\":{\"201\":1}}],[\"等差数列\",{\"0\":{\"200\":1,\"213\":1}}],[\"周期性\",{\"0\":{\"211\":1}}],[\"有根树\",{\"0\":{\"317\":1}}],[\"有穷自动机的分类\",{\"0\":{\"288\":1}}],[\"有穷自动机定义\",{\"0\":{\"285\":1}}],[\"有穷自动机\",{\"0\":{\"284\":1}}],[\"有界性\",{\"0\":{\"209\":1}}],[\"有限性\",{\"0\":{\"208\":1}}],[\"单调性\",{\"0\":{\"207\":1}}],[\"结论推广\",{\"0\":{\"199\":1}}],[\"平均数\",{\"0\":{\"197\":1}}],[\"平衡三进制\",{\"0\":{\"14\":1}}],[\"均值不等式\",{\"0\":{\"195\":1,\"198\":1}}],[\"不等式\",{\"0\":{\"194\":1}}],[\"不定方程\",{\"0\":{\"153\":1}}],[\"重要结论\",{\"0\":{\"192\":1}}],[\"柯西不等式表述\",{\"0\":{\"191\":1}}],[\"柯西不等式\",{\"0\":{\"190\":1}}],[\"用\",{\"0\":{\"189\":1}}],[\"拒绝采样的定义\",{\"0\":{\"187\":1}}],[\"拒绝采样\",{\"0\":{\"186\":1}}],[\"概率与统计\",{\"0\":{\"185\":1}}],[\"总结\",{\"0\":{\"183\":1}}],[\"l\",{\"0\":{\"301\":1}}],[\"lite\",{\"0\":{\"182\":1}}],[\"lpa\",{\"0\":{\"181\":1}}],[\"dfa\",{\"0\":{\"289\":1,\"291\":1,\"293\":1,\"297\":1,\"299\":1,\"302\":1,\"304\":1,\"305\":1}}],[\"d\",{\"0\":{\"180\":1,\"182\":1}}],[\"dijkstra\",{\"0\":{\"178\":1}}],[\"divisor\",{\"0\":{\"121\":1}}],[\"路径规划算法\",{\"0\":{\"177\":1}}],[\"欧拉筛法\",{\"0\":{\"176\":1}}],[\"欧几里得算法\",{\"0\":{\"165\":1}}],[\"埃拉托斯特尼筛法\",{\"0\":{\"175\":1}}],[\"暴力筛法\",{\"0\":{\"174\":1}}],[\"素数筛法\",{\"0\":{\"173\":1}}],[\"扩展欧几里得算法\",{\"0\":{\"169\":1}}],[\"递归法\",{\"0\":{\"166\":1}}],[\"递归版本\",{\"0\":{\"77\":1}}],[\"最小公倍数\",{\"0\":{\"170\":1}}],[\"最大公约数定义\",{\"0\":{\"164\":1}}],[\"最大公约数与最小公倍数\",{\"0\":{\"163\":1}}],[\"最低有效位\",{\"0\":{\"70\":1}}],[\"完全背包定义\",{\"0\":{\"334\":1}}],[\"完全背包\",{\"0\":{\"333\":1}}],[\"完全平方和问题\",{\"0\":{\"159\":1}}],[\"完全剩余系\",{\"0\":{\"152\":1}}],[\"多边形数\",{\"0\":{\"156\":1}}],[\"费马平方和定理\",{\"0\":{\"162\":1}}],[\"费马多边形定理\",{\"0\":{\"155\":1,\"157\":1}}],[\"费尔马小定理\",{\"0\":{\"148\":1}}],[\"孙子定理\",{\"0\":{\"154\":1}}],[\"剩余类性质\",{\"0\":{\"151\":1}}],[\"剩余类定义\",{\"0\":{\"150\":1}}],[\"剩余类和完全剩余系\",{\"0\":{\"149\":1}}],[\"常用的中间表示形式\",{\"0\":{\"250\":1}}],[\"常用性质\",{\"0\":{\"147\":1}}],[\"常见的集合\",{\"0\":{\"225\":1}}],[\"常见的数列\",{\"0\":{\"212\":1}}],[\"常见的公平组合游戏\",{\"0\":{\"119\":1}}],[\"常见的组合性质\",{\"0\":{\"33\":1}}],[\"常见算法\",{\"0\":{\"82\":1}}],[\"同余的性质\",{\"0\":{\"146\":1}}],[\"同余的定义\",{\"0\":{\"145\":1}}],[\"同余\",{\"0\":{\"144\":1}}],[\"哈密尔顿回路\",{\"0\":{\"143\":1}}],[\"一笔画问题\",{\"0\":{\"142\":1}}],[\"一般求解步骤\",{\"0\":{\"129\":1}}],[\"广度优先遍历\",{\"0\":{\"141\":1}}],[\"深度优先遍历\",{\"0\":{\"140\":1}}],[\"邻接表储存\",{\"0\":{\"138\":1}}],[\"邻接矩阵存储\",{\"0\":{\"137\":1}}],[\"图的遍历\",{\"0\":{\"139\":1}}],[\"图的存储结构\",{\"0\":{\"136\":1}}],[\"图的定义\",{\"0\":{\"134\":1}}],[\"图论\",{\"0\":{\"133\":1}}],[\"hdu1848\",{\"0\":{\"132\":1}}],[\"adt\",{\"0\":{\"309\":1,\"311\":1}}],[\"a\",{\"0\":{\"179\":1}}],[\"and\",{\"0\":{\"132\":1}}],[\"again\",{\"0\":{\"132\":2}}],[\"例题\",{\"0\":{\"131\":1,\"188\":1}}],[\"函数\",{\"0\":{\"128\":1}}],[\"函数的渐进的界\",{\"0\":{\"9\":1}}],[\"局面和其性质\",{\"0\":{\"127\":1}}],[\"定理\",{\"0\":{\"126\":1,\"130\":1}}],[\"定义\",{\"0\":{\"38\":1,\"303\":1}}],[\"s\",{\"0\":{\"301\":1}}],[\"subset\",{\"0\":{\"300\":1}}],[\"stein\",{\"0\":{\"168\":1}}],[\"stl\",{\"0\":{\"46\":1}}],[\"sg\",{\"0\":{\"126\":1,\"128\":1,\"130\":1}}],[\"wythoff\",{\"0\":{\"123\":1}}],[\"威佐夫博弈\",{\"0\":{\"123\":1}}],[\"bash\",{\"0\":{\"122\":1}}],[\"巴什博奕\",{\"0\":{\"122\":1}}],[\"除数博弈\",{\"0\":{\"121\":1}}],[\"game\",{\"0\":{\"120\":1,\"121\":1,\"122\":1,\"123\":1,\"124\":1}}],[\"博弈论\",{\"0\":{\"125\":1}}],[\"博弈论简介\",{\"0\":{\"115\":1}}],[\"博弈\",{\"0\":{\"120\":1,\"124\":1}}],[\"反常游戏\",{\"0\":{\"118\":1}}],[\"公平组合游戏\",{\"0\":{\"117\":1}}],[\"公式总结\",{\"0\":{\"63\":1}}],[\"公式和字体\",{\"0\":{\"17\":1}}],[\"非确定的有穷自动机\",{\"0\":{\"290\":1}}],[\"非公平组合游戏\",{\"0\":{\"116\":1}}],[\"非递归版本\",{\"0\":{\"78\":1}}],[\"动态规划\",{\"0\":{\"114\":1,\"161\":1}}],[\"动态数组\",{\"0\":{\"108\":1}}],[\"栈\",{\"0\":{\"113\":1}}],[\"队列\",{\"0\":{\"112\":1}}],[\"链表\",{\"0\":{\"111\":1}}],[\"使用紧凑数组\",{\"0\":{\"107\":1}}],[\"低层次数组\",{\"0\":{\"106\":1}}],[\"优化\",{\"0\":{\"100\":1,\"101\":1}}],[\"o\",{\"0\":{\"100\":1,\"101\":1,\"301\":1}}],[\"i\",{\"0\":{\"100\":1,\"101\":1}}],[\"i+1\",{\"0\":{\"69\":1}}],[\"竞赛指南\",{\"0\":{\"99\":1}}],[\"缩略词\",{\"0\":{\"98\":1}}],[\"术语表\",{\"0\":{\"97\":1}}],[\"高维前缀和\",{\"0\":{\"90\":1}}],[\"二叉树的性质\",{\"0\":{\"318\":1}}],[\"二叉树\",{\"0\":{\"312\":1}}],[\"二义性文法的判定\",{\"0\":{\"276\":1}}],[\"二义性文法\",{\"0\":{\"275\":1}}],[\"二项分布\",{\"0\":{\"184\":1}}],[\"二维前缀和\",{\"0\":{\"89\":1}}],[\"二分答案\",{\"0\":{\"49\":1}}],[\"二分查找\",{\"0\":{\"43\":1}}],[\"二分算法\",{\"0\":{\"42\":1}}],[\"其他形式的前缀和\",{\"0\":{\"88\":1}}],[\"前缀操作\",{\"0\":{\"87\":1}}],[\"前缀和的推广\",{\"0\":{\"85\":1}}],[\"前缀和定义\",{\"0\":{\"84\":1}}],[\"前缀和\",{\"0\":{\"83\":1}}],[\"后缀和\",{\"0\":{\"86\":1}}],[\"快速实现\",{\"0\":{\"167\":1}}],[\"快速幂算法\",{\"0\":{\"76\":1}}],[\"快速幂\",{\"0\":{\"75\":1}}],[\"快速最小公倍数\",{\"0\":{\"66\":1}}],[\"性质\",{\"0\":{\"74\":1}}],[\"差分数组的定义\",{\"0\":{\"73\":1}}],[\"差分数组\",{\"0\":{\"72\":1}}],[\"绝对值\",{\"0\":{\"71\":1}}],[\"位\",{\"0\":{\"69\":1}}],[\"位运算总结\",{\"0\":{\"64\":1}}],[\"位运算详解\",{\"0\":{\"55\":1}}],[\"位运算优先级\",{\"0\":{\"54\":1}}],[\"位运算的功能\",{\"0\":{\"53\":1}}],[\"位运算\",{\"0\":{\"52\":1}}],[\"第\",{\"0\":{\"69\":1}}],[\"第一类斯特林数\",{\"0\":{\"41\":1}}],[\"判断奇偶\",{\"0\":{\"67\":1}}],[\"交换两个数\",{\"0\":{\"65\":1}}],[\"8\",{\"0\":{\"63\":1}}],[\"7\",{\"0\":{\"62\":1,\"71\":1,\"302\":1,\"303\":1,\"304\":1,\"305\":1,\"306\":1}}],[\"右移\",{\"0\":{\"61\":1}}],[\"左移\",{\"0\":{\"60\":1}}],[\"异或\",{\"0\":{\"58\":1}}],[\"按位取反\",{\"0\":{\"59\":1}}],[\"按位或\",{\"0\":{\"57\":1}}],[\"按位与\",{\"0\":{\"56\":1}}],[\"三分法\",{\"0\":{\"51\":1}}],[\"6\",{\"0\":{\"51\":1,\"61\":1,\"70\":1,\"249\":1,\"250\":1,\"251\":1,\"252\":1,\"297\":1,\"298\":1,\"299\":1,\"300\":1,\"301\":1}}],[\"python\",{\"0\":{\"48\":1,\"96\":1,\"105\":1}}],[\"closure\",{\"0\":{\"301\":2}}],[\"construction\",{\"0\":{\"300\":1}}],[\"cfg\",{\"0\":{\"271\":1}}],[\"chomsky\",{\"0\":{\"269\":1}}],[\"c\",{\"0\":{\"47\":1,\"283\":1,\"301\":1}}],[\"c++\",{\"0\":{\"46\":1,\"95\":1,\"101\":1,\"104\":1}}],[\"实现\",{\"0\":{\"46\":1,\"189\":1}}],[\"实验结果\",{\"0\":{\"4\":1}}],[\"标准库实现\",{\"0\":{\"45\":1,\"92\":1,\"171\":1}}],[\"代码实现\",{\"0\":{\"44\":1}}],[\"斐波那契数列\",{\"0\":{\"37\":1,\"80\":1}}],[\"斐波那契数和组合数\",{\"0\":{\"35\":1}}],[\"维空间和组合数\",{\"0\":{\"36\":1}}],[\"nfa\",{\"0\":{\"290\":1,\"291\":1,\"292\":1,\"296\":1,\"297\":1,\"299\":1}}],[\"nim\",{\"0\":{\"120\":2,\"124\":2}}],[\"n\",{\"0\":{\"36\":3}}],[\"附录\",{\"0\":{\"34\":1,\"193\":1,\"199\":1,\"332\":1}}],[\"生成函数\",{\"0\":{\"32\":1}}],[\"组合数学\",{\"0\":{\"39\":1}}],[\"组合的有趣性质\",{\"0\":{\"34\":1}}],[\"组合恒等式\",{\"0\":{\"31\":1}}],[\"组合\",{\"0\":{\"30\":1}}],[\"排列数\",{\"0\":{\"29\":1}}],[\"排列组合基础\",{\"0\":{\"28\":1}}],[\"排列组合\",{\"0\":{\"24\":1}}],[\"乘法原理\",{\"0\":{\"27\":1}}],[\"加法原理\",{\"0\":{\"26\":1}}],[\"数列的常见性质\",{\"0\":{\"206\":1}}],[\"数列的定义\",{\"0\":{\"205\":1}}],[\"数列简介\",{\"0\":{\"204\":1}}],[\"数列\",{\"0\":{\"203\":1}}],[\"数组的定义\",{\"0\":{\"103\":1}}],[\"数组\",{\"0\":{\"102\":1,\"104\":1,\"105\":1}}],[\"数组初始化\",{\"0\":{\"95\":1,\"96\":1}}],[\"数组优化\",{\"0\":{\"94\":1}}],[\"数论\",{\"0\":{\"23\":1,\"172\":1}}],[\"数学符号定义\",{\"0\":{\"16\":1}}],[\"数学表示\",{\"0\":{\"12\":1}}],[\"5\",{\"0\":{\"23\":1,\"50\":1,\"60\":1,\"69\":1,\"92\":1,\"124\":1,\"131\":1,\"132\":1,\"154\":1,\"162\":1,\"170\":1,\"182\":1,\"211\":1,\"245\":1,\"246\":1,\"247\":1,\"248\":1,\"271\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":1,\"276\":2,\"293\":1,\"294\":1,\"295\":1,\"296\":1,\"331\":1}}],[\"求矩阵的快速幂\",{\"0\":{\"81\":1}}],[\"求积\",{\"0\":{\"22\":1}}],[\"求和\",{\"0\":{\"21\":1}}],[\"大型运算符\",{\"0\":{\"20\":1}}],[\"4\",{\"0\":{\"20\":1,\"21\":1,\"22\":1,\"49\":1,\"59\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":2,\"69\":1,\"70\":1,\"71\":1,\"81\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"123\":2,\"124\":1,\"130\":1,\"143\":1,\"153\":1,\"159\":1,\"160\":1,\"161\":1,\"169\":1,\"181\":1,\"210\":1,\"228\":1,\"229\":1,\"230\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":1,\"262\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"275\":1,\"288\":1,\"289\":1,\"290\":1,\"291\":1,\"292\":2,\"293\":1,\"301\":1,\"306\":1,\"323\":1,\"330\":1}}],[\"证明中的符号\",{\"0\":{\"19\":1}}],[\"基础概念\",{\"0\":{\"315\":1}}],[\"基础结论\",{\"0\":{\"229\":1}}],[\"基础数据结构\",{\"0\":{\"109\":1}}],[\"基础数学知识\",{\"0\":{\"15\":1}}],[\"基本思路\",{\"0\":{\"328\":1}}],[\"基本不等式\",{\"0\":{\"196\":1}}],[\"基本概念\",{\"0\":{\"135\":1}}],[\"基本\",{\"0\":{\"18\":1}}],[\"斯特林数\",{\"0\":{\"40\":1}}],[\"斯特林近似\",{\"0\":{\"13\":1}}],[\"斯特林公式\",{\"0\":{\"11\":1}}],[\"3\",{\"0\":{\"8\":1,\"9\":1,\"19\":1,\"45\":1,\"46\":1,\"47\":1,\"48\":2,\"55\":1,\"56\":1,\"57\":1,\"58\":2,\"59\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":1,\"67\":1,\"80\":1,\"88\":1,\"89\":1,\"90\":1,\"91\":2,\"105\":1,\"106\":1,\"107\":1,\"108\":2,\"118\":1,\"122\":1,\"129\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":2,\"143\":1,\"149\":1,\"150\":1,\"151\":1,\"152\":2,\"158\":1,\"168\":1,\"171\":1,\"180\":1,\"198\":1,\"209\":1,\"212\":1,\"213\":1,\"214\":1,\"215\":2,\"219\":1,\"225\":1,\"227\":1,\"238\":1,\"239\":1,\"240\":1,\"244\":1,\"248\":1,\"252\":1,\"257\":1,\"261\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":2,\"267\":1,\"274\":1,\"277\":1,\"278\":1,\"279\":1,\"280\":1,\"281\":1,\"282\":1,\"283\":1,\"284\":2,\"285\":2,\"286\":2,\"287\":3,\"288\":1,\"289\":1,\"290\":1,\"291\":2,\"292\":1,\"293\":1,\"294\":1,\"295\":1,\"296\":1,\"297\":1,\"298\":1,\"299\":1,\"300\":2,\"301\":1,\"302\":1,\"303\":1,\"304\":1,\"305\":2,\"306\":1,\"318\":1,\"322\":1,\"329\":1,\"336\":1}}],[\"伪代码编写\",{\"0\":{\"7\":1}}],[\"2\",{\"0\":{\"4\":1,\"7\":1,\"13\":1,\"18\":1,\"22\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":2,\"33\":1,\"44\":1,\"47\":1,\"54\":1,\"57\":1,\"66\":1,\"74\":1,\"78\":1,\"79\":1,\"85\":1,\"86\":1,\"87\":2,\"90\":1,\"96\":1,\"104\":1,\"107\":1,\"117\":1,\"121\":1,\"128\":1,\"135\":1,\"136\":1,\"137\":1,\"138\":2,\"141\":1,\"146\":1,\"147\":1,\"148\":2,\"151\":1,\"157\":1,\"161\":1,\"165\":1,\"166\":1,\"167\":2,\"175\":1,\"176\":1,\"179\":1,\"188\":1,\"189\":1,\"192\":1,\"197\":1,\"202\":1,\"206\":1,\"207\":1,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"214\":1,\"218\":1,\"224\":1,\"226\":1,\"230\":1,\"234\":1,\"235\":1,\"236\":1,\"237\":2,\"240\":1,\"243\":1,\"247\":1,\"251\":1,\"253\":1,\"254\":1,\"255\":1,\"256\":2,\"257\":1,\"258\":2,\"259\":2,\"260\":3,\"261\":2,\"262\":2,\"263\":1,\"264\":1,\"265\":2,\"266\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":2,\"271\":1,\"272\":1,\"273\":2,\"274\":1,\"275\":1,\"276\":1,\"280\":1,\"281\":1,\"282\":1,\"283\":2,\"286\":1,\"290\":1,\"296\":1,\"299\":1,\"304\":1,\"311\":1,\"317\":1,\"319\":1,\"320\":1,\"321\":2,\"322\":1,\"323\":1,\"328\":1,\"335\":1}}],[\"1\",{\"0\":{\"3\":1,\"6\":1,\"9\":1,\"12\":1,\"17\":1,\"21\":1,\"25\":1,\"26\":2,\"27\":1,\"29\":1,\"32\":1,\"38\":1,\"41\":1,\"43\":1,\"46\":1,\"53\":1,\"56\":1,\"65\":1,\"73\":1,\"76\":1,\"77\":2,\"78\":1,\"84\":1,\"86\":1,\"89\":1,\"95\":1,\"98\":1,\"101\":1,\"103\":1,\"106\":1,\"116\":1,\"120\":1,\"127\":1,\"132\":1,\"134\":1,\"135\":1,\"137\":1,\"140\":1,\"145\":1,\"147\":1,\"150\":1,\"156\":1,\"160\":1,\"164\":1,\"166\":1,\"174\":1,\"178\":1,\"187\":1,\"189\":1,\"191\":1,\"196\":1,\"201\":1,\"205\":1,\"207\":1,\"213\":1,\"217\":1,\"222\":1,\"223\":2,\"224\":1,\"225\":1,\"229\":1,\"231\":1,\"232\":2,\"233\":3,\"234\":2,\"235\":1,\"236\":2,\"237\":1,\"238\":1,\"239\":2,\"240\":1,\"241\":1,\"242\":2,\"243\":1,\"244\":1,\"245\":1,\"246\":2,\"247\":1,\"248\":1,\"249\":1,\"250\":2,\"251\":1,\"252\":1,\"254\":1,\"255\":2,\"256\":1,\"257\":1,\"259\":1,\"264\":1,\"269\":1,\"272\":1,\"278\":1,\"279\":2,\"280\":1,\"282\":1,\"285\":1,\"289\":1,\"295\":1,\"298\":1,\"303\":1,\"310\":1,\"315\":1,\"316\":2,\"317\":1,\"318\":1,\"320\":1,\"325\":1,\"326\":1,\"327\":2,\"334\":1}}],[\"算法实现\",{\"0\":{\"293\":1}}],[\"算法的数学基础\",{\"0\":{\"8\":1}}],[\"算法的基本概念\",{\"0\":{\"6\":1}}],[\"算法\",{\"0\":{\"5\":1,\"168\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":1,\"182\":1}}],[\"算法分析的目标\",{\"0\":{\"3\":1}}],[\"算法分析\",{\"0\":{\"2\":1,\"10\":1}}],[\"算法和数据结构笔记\",{\"0\":{\"0\":1}}],[\"相关领域\",{\"0\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
