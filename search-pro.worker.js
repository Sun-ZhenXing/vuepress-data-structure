const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;$(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&$(e.slice(0,-1),n,u)}},$=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",q="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},N=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[q]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:q,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=G(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:G(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(N),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(N),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":356,\"nextId\":356,\"documentIds\":{\"0\":\"v-8daa1a0e\",\"1\":\"v-8daa1a0e#相关领域\",\"2\":\"v-2bb655c3\",\"3\":\"v-2bb655c3#1-算法分析的目标\",\"4\":\"v-2bb655c3#2-实验结果\",\"5\":\"v-138e0bb4\",\"6\":\"v-138e0bb4#1-算法的基本概念\",\"7\":\"v-138e0bb4#2-伪代码编写\",\"8\":\"v-138e0bb4#3-算法的数学基础\",\"9\":\"v-138e0bb4#31-函数的渐进的界\",\"10\":\"v-05ed915c\",\"11\":\"v-6427756d\",\"12\":\"v-6427756d#1-数学表示\",\"13\":\"v-6427756d#2-斯特林近似\",\"14\":\"v-1b9a47b4\",\"15\":\"v-7fa3e1a2\",\"16\":\"v-f9c2c1c0\",\"17\":\"v-f9c2c1c0#1-公式和字体\",\"18\":\"v-f9c2c1c0#2-基本\",\"19\":\"v-f9c2c1c0#3-证明中的符号\",\"20\":\"v-f9c2c1c0#4-大型运算符\",\"21\":\"v-f9c2c1c0#41-求和\",\"22\":\"v-f9c2c1c0#42-求积\",\"23\":\"v-f9c2c1c0#5-数论\",\"24\":\"v-16ce8cd6\",\"25\":\"v-16ce8cd6#1-计数原理\",\"26\":\"v-16ce8cd6#11-加法原理\",\"27\":\"v-16ce8cd6#12-乘法原理\",\"28\":\"v-16ce8cd6#2-排列组合基础\",\"29\":\"v-16ce8cd6#21-排列数\",\"30\":\"v-16ce8cd6#22-组合\",\"31\":\"v-28bf815b\",\"32\":\"v-28bf815b#1-生成函数\",\"33\":\"v-28bf815b#2-常见的组合性质\",\"34\":\"v-28bf815b#附录组合的有趣性质\",\"35\":\"v-28bf815b#斐波那契数和组合数\",\"36\":\"v-28bf815b#-维空间和组合数\",\"37\":\"v-2ff9b25e\",\"38\":\"v-2ff9b25e#1-定义\",\"39\":\"v-4258002b\",\"40\":\"v-b29b981e\",\"41\":\"v-b29b981e#1-第一类斯特林数\",\"42\":\"v-78a4f5b4\",\"43\":\"v-78a4f5b4#1-二分查找\",\"44\":\"v-78a4f5b4#2-代码实现\",\"45\":\"v-78a4f5b4#3-标准库实现\",\"46\":\"v-78a4f5b4#31-c-stl-实现\",\"47\":\"v-78a4f5b4#32-c-语言\",\"48\":\"v-78a4f5b4#33-python\",\"49\":\"v-78a4f5b4#4-二分答案\",\"50\":\"v-78a4f5b4#5-分数规划\",\"51\":\"v-78a4f5b4#6-三分法\",\"52\":\"v-5549b110\",\"53\":\"v-5549b110#1-位运算的功能\",\"54\":\"v-5549b110#2-位运算优先级\",\"55\":\"v-5549b110#3-位运算详解\",\"56\":\"v-5549b110#31-按位与\",\"57\":\"v-5549b110#32-按位或\",\"58\":\"v-5549b110#33-异或\",\"59\":\"v-5549b110#34-按位取反\",\"60\":\"v-5549b110#35-左移\",\"61\":\"v-5549b110#36-右移\",\"62\":\"v-5549b110#37-无符号右移\",\"63\":\"v-5549b110#38-公式总结\",\"64\":\"v-5549b110#4-位运算总结\",\"65\":\"v-5549b110#41-交换两个数\",\"66\":\"v-5549b110#42-快速最小公倍数\",\"67\":\"v-5549b110#43-判断奇偶\",\"68\":\"v-5549b110#44-符号相同\",\"69\":\"v-5549b110#45-第-i1-位\",\"70\":\"v-5549b110#46-最低有效位\",\"71\":\"v-5549b110#47-绝对值\",\"72\":\"v-009cf31e\",\"73\":\"v-009cf31e#1-差分数组的定义\",\"74\":\"v-009cf31e#2-性质\",\"75\":\"v-aae83fba\",\"76\":\"v-aae83fba#1-快速幂算法\",\"77\":\"v-aae83fba#11-递归版本\",\"78\":\"v-aae83fba#12-非递归版本\",\"79\":\"v-aae83fba#2-模意义下取幂\",\"80\":\"v-aae83fba#3-斐波那契数列\",\"81\":\"v-aae83fba#4-求矩阵的快速幂\",\"82\":\"v-232b9ca2\",\"83\":\"v-aae2cd32\",\"84\":\"v-aae2cd32#1-前缀和定义\",\"85\":\"v-aae2cd32#2-前缀和的推广\",\"86\":\"v-aae2cd32#21-后缀和\",\"87\":\"v-aae2cd32#22-前缀操作\",\"88\":\"v-aae2cd32#3-其他形式的前缀和\",\"89\":\"v-aae2cd32#31-二维前缀和\",\"90\":\"v-aae2cd32#32-高维前缀和\",\"91\":\"v-aae2cd32#33-树形前缀和\",\"92\":\"v-aae2cd32#5-标准库实现\",\"93\":\"v-e4d6f294\",\"94\":\"v-7aab689f\",\"95\":\"v-7aab689f#1-c-数组初始化\",\"96\":\"v-7aab689f#2-python-数组初始化\",\"97\":\"v-56b80a9c\",\"98\":\"v-56b80a9c#1-缩略词\",\"99\":\"v-2ac76582\",\"100\":\"v-2942cd58\",\"101\":\"v-2942cd58#1-c-io-优化\",\"102\":\"v-0e781205\",\"103\":\"v-0e781205#1-数组的定义\",\"104\":\"v-0e781205#2-c-数组\",\"105\":\"v-0e781205#3-python-数组\",\"106\":\"v-0e781205#31-低层次数组\",\"107\":\"v-0e781205#32-使用紧凑数组\",\"108\":\"v-0e781205#33-动态数组\",\"109\":\"v-807743b6\",\"110\":\"v-807743b6#目录\",\"111\":\"v-5a15346c\",\"112\":\"v-6d6e4366\",\"113\":\"v-5fc0f194\",\"114\":\"v-ed464c86\",\"115\":\"v-4cb706d2\",\"116\":\"v-4cb706d2#1-非公平组合游戏\",\"117\":\"v-4cb706d2#2-公平组合游戏\",\"118\":\"v-4cb706d2#3-反常游戏\",\"119\":\"v-4cb706d2#4-常见的公平组合游戏\",\"120\":\"v-4cb706d2#41-简化的-nim-博弈nim-game\",\"121\":\"v-4cb706d2#42-除数博弈divisor-game\",\"122\":\"v-4cb706d2#43-巴什博奕bash-game\",\"123\":\"v-4cb706d2#44-威佐夫博弈wythoff-game\",\"124\":\"v-4cb706d2#45-nim-博弈nim-game\",\"125\":\"v-1b4ab288\",\"126\":\"v-7f8f5394\",\"127\":\"v-7f8f5394#1-局面和其性质\",\"128\":\"v-7f8f5394#2-sg-函数\",\"129\":\"v-7f8f5394#3-一般求解步骤\",\"130\":\"v-7f8f5394#4-sg-定理\",\"131\":\"v-7f8f5394#5-例题\",\"132\":\"v-7f8f5394#51-fibonacci-again-and-againhdu1848\",\"133\":\"v-30f43012\",\"134\":\"v-30f43012#1-图的定义\",\"135\":\"v-30f43012#12-基本概念\",\"136\":\"v-30f43012#2-图的存储结构\",\"137\":\"v-30f43012#21-邻接矩阵存储\",\"138\":\"v-30f43012#22-邻接表储存\",\"139\":\"v-30f43012#3-图的遍历\",\"140\":\"v-30f43012#31-深度优先遍历\",\"141\":\"v-30f43012#32-广度优先遍历\",\"142\":\"v-30f43012#33-一笔画问题\",\"143\":\"v-30f43012#34-哈密尔顿回路\",\"144\":\"v-2c6e30b0\",\"145\":\"v-2c6e30b0#1-同余的定义\",\"146\":\"v-2c6e30b0#2-同余的性质\",\"147\":\"v-2c6e30b0#21-常用性质\",\"148\":\"v-2c6e30b0#22-费尔马小定理\",\"149\":\"v-2c6e30b0#3-剩余类和完全剩余系\",\"150\":\"v-2c6e30b0#31-剩余类定义\",\"151\":\"v-2c6e30b0#32-剩余类性质\",\"152\":\"v-2c6e30b0#33-完全剩余系\",\"153\":\"v-2c6e30b0#4-不定方程\",\"154\":\"v-2c6e30b0#5-孙子定理\",\"155\":\"v-76278df8\",\"156\":\"v-76278df8#1-多边形数\",\"157\":\"v-76278df8#2-费马多边形定理\",\"158\":\"v-76278df8#3-四平方和定理\",\"159\":\"v-76278df8#4-完全平方和问题\",\"160\":\"v-76278df8#41-四平方和定理解答\",\"161\":\"v-76278df8#42-动态规划\",\"162\":\"v-76278df8#5-费马平方和定理\",\"163\":\"v-6983b586\",\"164\":\"v-6983b586#1-最大公约数定义\",\"165\":\"v-6983b586#2-欧几里得算法\",\"166\":\"v-6983b586#21-递归法\",\"167\":\"v-6983b586#22-快速实现\",\"168\":\"v-6983b586#3-stein-算法\",\"169\":\"v-6983b586#4-扩展欧几里得算法\",\"170\":\"v-6983b586#5-最小公倍数\",\"171\":\"v-6983b586#3-标准库实现\",\"172\":\"v-310afec2\",\"173\":\"v-0051b9bc\",\"174\":\"v-0051b9bc#1-暴力筛法\",\"175\":\"v-0051b9bc#2-埃拉托斯特尼筛法\",\"176\":\"v-0051b9bc#2-欧拉筛法\",\"177\":\"v-5cb727fa\",\"178\":\"v-5cb727fa#1-dijkstra-算法\",\"179\":\"v-5cb727fa#2-a-算法\",\"180\":\"v-5cb727fa#3-d-算法\",\"181\":\"v-5cb727fa#4-lpa-算法\",\"182\":\"v-5cb727fa#5-d-lite-算法\",\"183\":\"v-5cb727fa#总结\",\"184\":\"v-9403fcc8\",\"185\":\"v-03a27c45\",\"186\":\"v-6d9f9369\",\"187\":\"v-6d9f9369#1-拒绝采样的定义\",\"188\":\"v-6d9f9369#2-例题\",\"189\":\"v-6d9f9369#21-用-rand7-实现-rand10\",\"190\":\"v-111740bc\",\"191\":\"v-83cf780e\",\"192\":\"v-9b64c5f0\",\"193\":\"v-85a62f2a\",\"194\":\"v-85a62f2a#1-柯西不等式表述\",\"195\":\"v-85a62f2a#2-重要结论\",\"196\":\"v-85a62f2a#附录构造函数证明柯西不等式\",\"197\":\"v-05030461\",\"198\":\"v-13d802f3\",\"199\":\"v-13d802f3#1-基本不等式\",\"200\":\"v-13d802f3#2-平均数\",\"201\":\"v-13d802f3#3-均值不等式\",\"202\":\"v-13d802f3#附录结论推广\",\"203\":\"v-0ea405e8\",\"204\":\"v-0ea405e8#1-等差数列定义\",\"205\":\"v-0ea405e8#2-等差数列的性质\",\"206\":\"v-373d6f8e\",\"207\":\"v-09c96424\",\"208\":\"v-09c96424#1-数列的定义\",\"209\":\"v-09c96424#2-数列的常见性质\",\"210\":\"v-09c96424#21-单调性\",\"211\":\"v-09c96424#22-有限性\",\"212\":\"v-09c96424#23-有界性\",\"213\":\"v-09c96424#24-收敛性\",\"214\":\"v-09c96424#25-周期性\",\"215\":\"v-09c96424#3-常见的数列\",\"216\":\"v-09c96424#31-等差数列\",\"217\":\"v-09c96424#32-等比数列\",\"218\":\"v-09c96424#33-等和数列\",\"219\":\"v-12eefd78\",\"220\":\"v-12eefd78#11-随机试验\",\"221\":\"v-12eefd78#12-概率的定义\",\"222\":\"v-04bc9a7a\",\"223\":\"v-b36a4586\",\"224\":\"v-b36a4586#1-集合的划分\",\"225\":\"v-b36a4586#2-容斥公式\",\"226\":\"v-b36a4586#3-筛法公式\",\"227\":\"v-2e3b5af0\",\"228\":\"v-24115ca7\",\"229\":\"v-24115ca7#1-集合\",\"230\":\"v-24115ca7#11-集合的定义\",\"231\":\"v-24115ca7#12-集合的表示\",\"232\":\"v-24115ca7#13-常见的集合\",\"233\":\"v-24115ca7#2-区间\",\"234\":\"v-24115ca7#3-集合的运算\",\"235\":\"v-24115ca7#4-集合运算的性质\",\"236\":\"v-24115ca7#41-基础结论\",\"237\":\"v-24115ca7#42-运算性质\",\"238\":\"v-695117e8\",\"239\":\"v-a3a5b4da\",\"240\":\"v-f991e8b0\",\"241\":\"v-f991e8b0#1-概念\",\"242\":\"v-f991e8b0#11-勾股定理\",\"243\":\"v-f991e8b0#12-半角公式\",\"244\":\"v-f991e8b0#13-二倍角公式\",\"245\":\"v-f991e8b0#14-三倍角公式\",\"246\":\"v-f991e8b0#15-和差化积\",\"247\":\"v-f991e8b0#16-积化合差\",\"248\":\"v-f991e8b0#17-万能公式\",\"249\":\"v-35b1da17\",\"250\":\"v-35b1da17#11-什么是编译\",\"251\":\"v-35b1da17#111-计算机程序设计语言及编译\",\"252\":\"v-35b1da17#112-编译器在语言处理系统中的位置\",\"253\":\"v-35b1da17#12-编译系统的结构\",\"254\":\"v-35b1da17#121-人工英汉翻译的例子\",\"255\":\"v-35b1da17#122-编译器的结构\",\"256\":\"v-35b1da17#13-词法分析概述\",\"257\":\"v-35b1da17#131-词法分析的主要任务\",\"258\":\"v-35b1da17#132-词法分析后得到的-token-序列\",\"259\":\"v-35b1da17#14-语法分析概述\",\"260\":\"v-35b1da17#141-语法分析器\",\"261\":\"v-35b1da17#142-赋值语句分析树\",\"262\":\"v-35b1da17#143-变量声明语句的分析树\",\"263\":\"v-35b1da17#15-语义分析概述\",\"264\":\"v-35b1da17#151-语义分析的主要任务\",\"265\":\"v-35b1da17#152-收集标识符的属性信息\",\"266\":\"v-35b1da17#153-语义检查\",\"267\":\"v-35b1da17#16-中间代码生成和编译器后端\",\"268\":\"v-35b1da17#161-常用的中间表示形式\",\"269\":\"v-35b1da17#162-中间代码生成的例子\",\"270\":\"v-35b1da17#163-目标代码生成\",\"271\":\"v-35b1da36\",\"272\":\"v-35b1da36#21-词法语法分析基本概念\",\"273\":\"v-35b1da36#211-字母表\",\"274\":\"v-35b1da36#212-字母表上的运算\",\"275\":\"v-35b1da36#213-串上的运算\",\"276\":\"v-35b1da36#22-文法定义\",\"277\":\"v-35b1da36#221-文法的定义\",\"278\":\"v-35b1da36#222-简化后的算数表达式的文法\",\"279\":\"v-35b1da36#223-产生式的简写\",\"280\":\"v-35b1da36#224-符号约定\",\"281\":\"v-35b1da36#23-语言的定义\",\"282\":\"v-35b1da36#231-推导和归约\",\"283\":\"v-35b1da36#232-句型和句子\",\"284\":\"v-35b1da36#233-练习写出无符号整数和浮点数的文法\",\"285\":\"v-35b1da36#234-语言上的运算\",\"286\":\"v-35b1da36#24-文法的分类\",\"287\":\"v-35b1da36#241-chomsky-文法分类体系\",\"288\":\"v-35b1da36#242-四种文法的关系\",\"289\":\"v-35b1da36#25-cfg-的分析树\",\"290\":\"v-35b1da36#251-举例分析\",\"291\":\"v-35b1da36#252-分析树推导的图形化表示\",\"292\":\"v-35b1da36#253-句型的短语\",\"293\":\"v-35b1da36#254-二义性文法\",\"294\":\"v-35b1da36#255-二义性文法的判定\",\"295\":\"v-35b1da55\",\"296\":\"v-35b1da55#31-正则表达式\",\"297\":\"v-35b1da55#311-正则表达式定义\",\"298\":\"v-35b1da55#312-正则表达式与正则文法是等价的\",\"299\":\"v-35b1da55#32-正则定义\",\"300\":\"v-35b1da55#321-什么是正则定义\",\"301\":\"v-35b1da55#322-c-语言标识符的正则定义\",\"302\":\"v-35b1da55#33-有穷自动机\",\"303\":\"v-35b1da55#331-有穷自动机定义\",\"304\":\"v-35b1da55#332-fa-的典型例子\",\"305\":\"v-35b1da55#333-fa-接收的语言\",\"306\":\"v-35b1da55#34-有穷自动机的分类\",\"307\":\"v-35b1da55#341-确定的有穷自动机dfa\",\"308\":\"v-35b1da55#342-非确定的有穷自动机nfa\",\"309\":\"v-35b1da55#343-dfa-和-nfa-的等价性\",\"310\":\"v-35b1da55#344-带-ε-边-的-nfa\",\"311\":\"v-35b1da55#345-dfa-算法实现\",\"312\":\"v-35b1da55#35-从正则表达式到有穷自动机\",\"313\":\"v-35b1da55#351-构造方法\",\"314\":\"v-35b1da55#352-根据-re-构造-nfa\",\"315\":\"v-35b1da55#36-从-nfa-到-dfa-的转换\",\"316\":\"v-35b1da55#361-转换示例\",\"317\":\"v-35b1da55#362-带有空边的-nfa-到-dfa\",\"318\":\"v-35b1da55#363-子集构造法subset-construction\",\"319\":\"v-35b1da55#364-计算-\",\"320\":\"v-35b1da55#37-识别单词的-dfa\",\"321\":\"v-35b1da55#371-定义\",\"322\":\"v-35b1da55#372-识别注释的-dfa\",\"323\":\"v-35b1da55#373-识别-token-的-dfa\",\"324\":\"v-35b1da55#374-词法分析阶段中的错误处理\",\"325\":\"v-6ca493b2\",\"326\":\"v-087c593e\",\"327\":\"v-6dbdbc85\",\"328\":\"v-6dbdbc85#1-集合的定义\",\"329\":\"v-6dbdbc85#2-集合-adt\",\"330\":\"v-6bfacb0a\",\"331\":\"v-2801b14c\",\"332\":\"v-d55937a2\",\"333\":\"v-d55937a2#1-基础概念\",\"334\":\"v-d55937a2#11-无根树\",\"335\":\"v-d55937a2#12-有根树\",\"336\":\"v-d55937a2#13-二叉树的性质\",\"337\":\"v-d55937a2#2-树的储存结构\",\"338\":\"v-d55937a2#21-父结点表示法\",\"339\":\"v-d55937a2#22-子结点表示法\",\"340\":\"v-d55937a2#23-父亲孩子表示法\",\"341\":\"v-d55937a2#24-孩子兄弟表示法\",\"342\":\"v-58e45a54\",\"343\":\"v-58e45a54#1-字典树的定义\",\"344\":\"v-ac98ccb0\",\"345\":\"v-ac98ccb0#1-0-1-背包理论\",\"346\":\"v-ac98ccb0#2-基本思路\",\"347\":\"v-ac98ccb0#3-滚动数组\",\"348\":\"v-ac98ccb0#4-模板总结\",\"349\":\"v-ac98ccb0#5-获取背包的内容\",\"350\":\"v-ac98ccb0#附录背包与贪心问题\",\"351\":\"v-6e9acf86\",\"352\":\"v-6e9acf86#1-完全背包定义\",\"353\":\"v-6e9acf86#2-模板总结\",\"354\":\"v-6e9acf86#3-获取完全背包内的物品\",\"355\":\"v-94823b10\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1],\"2\":[1],\"3\":[2],\"4\":[2],\"5\":[1],\"6\":[2],\"7\":[2],\"8\":[2],\"9\":[3],\"10\":[1],\"11\":[1],\"12\":[2],\"13\":[2],\"14\":[1],\"15\":[1],\"16\":[1],\"17\":[2],\"18\":[2],\"19\":[2],\"20\":[2],\"21\":[3],\"22\":[3],\"23\":[2],\"24\":[1],\"25\":[2],\"26\":[2],\"27\":[3],\"28\":[2],\"29\":[3],\"30\":[2],\"31\":[1],\"32\":[2],\"33\":[2],\"34\":[2],\"35\":[1],\"36\":[2],\"37\":[1],\"38\":[2],\"39\":[1],\"40\":[1],\"41\":[2],\"42\":[1],\"43\":[2],\"44\":[2],\"45\":[2],\"46\":[5],\"47\":[4],\"48\":[2],\"49\":[2],\"50\":[2],\"51\":[2],\"52\":[1],\"53\":[2],\"54\":[2],\"55\":[2],\"56\":[3],\"57\":[3],\"58\":[2],\"59\":[3],\"60\":[3],\"61\":[3],\"62\":[3],\"63\":[3],\"64\":[2],\"65\":[3],\"66\":[3],\"67\":[3],\"68\":[2],\"69\":[5],\"70\":[3],\"71\":[3],\"72\":[1],\"73\":[2],\"74\":[2],\"75\":[1],\"76\":[2],\"77\":[2],\"78\":[3],\"79\":[2],\"80\":[2],\"81\":[2],\"82\":[1],\"83\":[1],\"84\":[2],\"85\":[2],\"86\":[3],\"87\":[2],\"88\":[2],\"89\":[3],\"90\":[3],\"91\":[2],\"92\":[2],\"93\":[1],\"94\":[1],\"95\":[3],\"96\":[3],\"97\":[1],\"98\":[2],\"99\":[1],\"100\":[3],\"101\":[5],\"102\":[1],\"103\":[2],\"104\":[3],\"105\":[3],\"106\":[3],\"107\":[3],\"108\":[2],\"109\":[1],\"110\":[1],\"111\":[1],\"112\":[1],\"113\":[1],\"114\":[1],\"115\":[1],\"116\":[2],\"117\":[2],\"118\":[2],\"119\":[2],\"120\":[7],\"121\":[6],\"122\":[6],\"123\":[5],\"124\":[6],\"125\":[1],\"126\":[2],\"127\":[2],\"128\":[3],\"129\":[2],\"130\":[3],\"131\":[2],\"132\":[7],\"133\":[1],\"134\":[2],\"135\":[3],\"136\":[2],\"137\":[3],\"138\":[2],\"139\":[2],\"140\":[3],\"141\":[3],\"142\":[2],\"143\":[3],\"144\":[1],\"145\":[2],\"146\":[2],\"147\":[3],\"148\":[2],\"149\":[2],\"150\":[3],\"151\":[3],\"152\":[2],\"153\":[2],\"154\":[2],\"155\":[1],\"156\":[2],\"157\":[2],\"158\":[2],\"159\":[2],\"160\":[3],\"161\":[3],\"162\":[2],\"163\":[1],\"164\":[2],\"165\":[2],\"166\":[3],\"167\":[2],\"168\":[3],\"169\":[2],\"170\":[2],\"171\":[2],\"172\":[1],\"173\":[1],\"174\":[2],\"175\":[2],\"176\":[2],\"177\":[1],\"178\":[3],\"179\":[3],\"180\":[3],\"181\":[3],\"182\":[4],\"183\":[1],\"184\":[1],\"185\":[1],\"186\":[1],\"187\":[2],\"188\":[2],\"189\":[6],\"190\":[1],\"191\":[1],\"192\":[1],\"193\":[1],\"194\":[2],\"195\":[2],\"196\":[2],\"197\":[1],\"198\":[1],\"199\":[2],\"200\":[2],\"201\":[2],\"202\":[2],\"203\":[1],\"204\":[2],\"205\":[2],\"206\":[1],\"207\":[1],\"208\":[2],\"209\":[2],\"210\":[3],\"211\":[2],\"212\":[3],\"213\":[3],\"214\":[3],\"215\":[2],\"216\":[3],\"217\":[3],\"218\":[2],\"219\":[2],\"220\":[2],\"221\":[3],\"222\":[1],\"223\":[1],\"224\":[2],\"225\":[2],\"226\":[2],\"227\":[1],\"228\":[1],\"229\":[2],\"230\":[2],\"231\":[3],\"232\":[3],\"233\":[2],\"234\":[2],\"235\":[2],\"236\":[3],\"237\":[3],\"238\":[1],\"239\":[1],\"240\":[1],\"241\":[4],\"242\":[2],\"243\":[3],\"244\":[3],\"245\":[3],\"246\":[3],\"247\":[3],\"248\":[3],\"249\":[2],\"250\":[2],\"251\":[2],\"252\":[3],\"253\":[3],\"254\":[3],\"255\":[3],\"256\":[3],\"257\":[3],\"258\":[6],\"259\":[3],\"260\":[3],\"261\":[4],\"262\":[4],\"263\":[3],\"264\":[3],\"265\":[4],\"266\":[4],\"267\":[3],\"268\":[3],\"269\":[4],\"270\":[4],\"271\":[2],\"272\":[3],\"273\":[3],\"274\":[3],\"275\":[4],\"276\":[2],\"277\":[3],\"278\":[2],\"279\":[3],\"280\":[3],\"281\":[3],\"282\":[4],\"283\":[3],\"284\":[4],\"285\":[4],\"286\":[3],\"287\":[5],\"288\":[3],\"289\":[4],\"290\":[4],\"291\":[3],\"292\":[4],\"293\":[4],\"294\":[3],\"295\":[2],\"296\":[3],\"297\":[3],\"298\":[4],\"299\":[3],\"300\":[4],\"301\":[4],\"302\":[2],\"303\":[3],\"304\":[4],\"305\":[3],\"306\":[3],\"307\":[6],\"308\":[6],\"309\":[6],\"310\":[7],\"311\":[5],\"312\":[3],\"313\":[4],\"314\":[7],\"315\":[7],\"316\":[4],\"317\":[7],\"318\":[6],\"319\":[17],\"320\":[4],\"321\":[4],\"322\":[5],\"323\":[6],\"324\":[4],\"325\":[1],\"326\":[3],\"327\":[2],\"328\":[2],\"329\":[3],\"330\":[1],\"331\":[1],\"332\":[1],\"333\":[2],\"334\":[2],\"335\":[3],\"336\":[3],\"337\":[2],\"338\":[3],\"339\":[2],\"340\":[3],\"341\":[3],\"342\":[1],\"343\":[2],\"344\":[3],\"345\":[3],\"346\":[2],\"347\":[2],\"348\":[2],\"349\":[2],\"350\":[2],\"351\":[1],\"352\":[2],\"353\":[2],\"354\":[2],\"355\":[1]},\"averageFieldLength\":[2.542134831460674],\"storedFields\":{\"0\":{\"h\":\"算法和数据结构笔记\"},\"1\":{\"h\":\"相关领域\"},\"2\":{\"h\":\"算法分析\"},\"3\":{\"h\":\"1. 算法分析的目标\"},\"4\":{\"h\":\"2. 实验结果\"},\"5\":{\"h\":\"算法\"},\"6\":{\"h\":\"1. 算法的基本概念\"},\"7\":{\"h\":\"2. 伪代码编写\"},\"8\":{\"h\":\"3. 算法的数学基础\"},\"9\":{\"h\":\"3.1 函数的渐进的界\"},\"10\":{\"h\":\"算法分析\"},\"11\":{\"h\":\"斯特林公式\"},\"12\":{\"h\":\"1. 数学表示\"},\"13\":{\"h\":\"2. 斯特林近似\"},\"14\":{\"h\":\"平衡三进制\"},\"15\":{\"h\":\"基础数学知识\"},\"16\":{\"h\":\"数学符号定义\"},\"17\":{\"h\":\"1. 公式和字体\"},\"18\":{\"h\":\"2. 基本\"},\"19\":{\"h\":\"3. 证明中的符号\"},\"20\":{\"h\":\"4. 大型运算符\"},\"21\":{\"h\":\"4.1 求和\"},\"22\":{\"h\":\"4.2 求积\"},\"23\":{\"h\":\"5. 数论\"},\"24\":{\"h\":\"排列组合\"},\"25\":{\"h\":\"1. 计数原理\"},\"26\":{\"h\":\"1.1 加法原理\"},\"27\":{\"h\":\"1.2 乘法原理\"},\"28\":{\"h\":\"2. 排列组合基础\"},\"29\":{\"h\":\"2.1 排列数\"},\"30\":{\"h\":\"2.2. 组合\"},\"31\":{\"h\":\"组合恒等式\"},\"32\":{\"h\":\"1. 生成函数\"},\"33\":{\"h\":\"2. 常见的组合性质\"},\"34\":{\"h\":\"附录：组合的有趣性质\"},\"35\":{\"h\":\"斐波那契数和组合数\"},\"36\":{\"h\":\"n n n 维空间和组合数\"},\"37\":{\"h\":\"斐波那契数列\"},\"38\":{\"h\":\"1. 定义\"},\"39\":{\"h\":\"组合数学\"},\"40\":{\"h\":\"斯特林数\"},\"41\":{\"h\":\"1. 第一类斯特林数\"},\"42\":{\"h\":\"二分算法\"},\"43\":{\"h\":\"1. 二分查找\"},\"44\":{\"h\":\"2. 代码实现\"},\"45\":{\"h\":\"3. 标准库实现\"},\"46\":{\"h\":\"3.1 C++ STL 实现\"},\"47\":{\"h\":\"3.2 C 语言\"},\"48\":{\"h\":\"3.3 Python\"},\"49\":{\"h\":\"4. 二分答案\"},\"50\":{\"h\":\"5. 分数规划\"},\"51\":{\"h\":\"6. 三分法\"},\"52\":{\"h\":\"位运算\"},\"53\":{\"h\":\"1. 位运算的功能\"},\"54\":{\"h\":\"2. 位运算优先级\"},\"55\":{\"h\":\"3. 位运算详解\"},\"56\":{\"h\":\"3.1 按位与\"},\"57\":{\"h\":\"3.2 按位或\"},\"58\":{\"h\":\"3.3 异或\"},\"59\":{\"h\":\"3.4 按位取反\"},\"60\":{\"h\":\"3.5 左移\"},\"61\":{\"h\":\"3.6 右移\"},\"62\":{\"h\":\"3.7 无符号右移\"},\"63\":{\"h\":\"3.8 公式总结\"},\"64\":{\"h\":\"4. 位运算总结\"},\"65\":{\"h\":\"4.1 交换两个数\"},\"66\":{\"h\":\"4.2 快速最小公倍数\"},\"67\":{\"h\":\"4.3 判断奇偶\"},\"68\":{\"h\":\"4.4 符号相同\"},\"69\":{\"h\":\"4.5 第 i+1 位\"},\"70\":{\"h\":\"4.6 最低有效位\"},\"71\":{\"h\":\"4.7 绝对值\"},\"72\":{\"h\":\"差分数组\"},\"73\":{\"h\":\"1. 差分数组的定义\"},\"74\":{\"h\":\"2. 性质\"},\"75\":{\"h\":\"快速幂\"},\"76\":{\"h\":\"1. 快速幂算法\"},\"77\":{\"h\":\"1.1 递归版本\"},\"78\":{\"h\":\"1.2 非递归版本\"},\"79\":{\"h\":\"2. 模意义下取幂\"},\"80\":{\"h\":\"3. 斐波那契数列\"},\"81\":{\"h\":\"4. 求矩阵的快速幂\"},\"82\":{\"h\":\"常见算法\"},\"83\":{\"h\":\"前缀和\"},\"84\":{\"h\":\"1. 前缀和定义\"},\"85\":{\"h\":\"2. 前缀和的推广\"},\"86\":{\"h\":\"2.1 后缀和\"},\"87\":{\"h\":\"2.2 前缀操作\"},\"88\":{\"h\":\"3. 其他形式的前缀和\"},\"89\":{\"h\":\"3.1 二维前缀和\"},\"90\":{\"h\":\"3.2 高维前缀和\"},\"91\":{\"h\":\"3.3 树形前缀和\"},\"92\":{\"h\":\"5. 标准库实现\"},\"93\":{\"h\":\"编译原理\"},\"94\":{\"h\":\"数组优化\"},\"95\":{\"h\":\"1. C++ 数组初始化\"},\"96\":{\"h\":\"2. Python 数组初始化\"},\"97\":{\"h\":\"术语表\"},\"98\":{\"h\":\"1. 缩略词\"},\"99\":{\"h\":\"竞赛指南\"},\"100\":{\"h\":\"I/O 优化\"},\"101\":{\"h\":\"1. C++ I/O 优化\"},\"102\":{\"h\":\"数组\"},\"103\":{\"h\":\"1. 数组的定义\"},\"104\":{\"h\":\"2. C++ 数组\"},\"105\":{\"h\":\"3. Python 数组\"},\"106\":{\"h\":\"3.1 低层次数组\"},\"107\":{\"h\":\"3.2 使用紧凑数组\"},\"108\":{\"h\":\"3.3 动态数组\"},\"109\":{\"h\":\"基础数据结构\"},\"110\":{\"h\":\"目录\"},\"111\":{\"h\":\"链表\"},\"112\":{\"h\":\"队列\"},\"113\":{\"h\":\"栈\"},\"114\":{\"h\":\"动态规划\"},\"115\":{\"h\":\"博弈论简介\"},\"116\":{\"h\":\"1. 非公平组合游戏\"},\"117\":{\"h\":\"2. 公平组合游戏\"},\"118\":{\"h\":\"3. 反常游戏\"},\"119\":{\"h\":\"4. 常见的公平组合游戏\"},\"120\":{\"h\":\"4.1 简化的 Nim 博弈（Nim Game）\"},\"121\":{\"h\":\"4.2 除数博弈（Divisor Game）\"},\"122\":{\"h\":\"4.3 巴什博奕（Bash Game）\"},\"123\":{\"h\":\"4.4 威佐夫博弈（Wythoff Game）\"},\"124\":{\"h\":\"4.5 Nim 博弈（Nim Game）\"},\"125\":{\"h\":\"博弈论\"},\"126\":{\"h\":\"SG 定理\"},\"127\":{\"h\":\"1. 局面和其性质\"},\"128\":{\"h\":\"2. SG 函数\"},\"129\":{\"h\":\"3. 一般求解步骤\"},\"130\":{\"h\":\"4. SG 定理\"},\"131\":{\"h\":\"5. 例题\"},\"132\":{\"h\":\"5.1 Fibonacci again and again(HDU1848)\"},\"133\":{\"h\":\"图论\"},\"134\":{\"h\":\"1. 图的定义\"},\"135\":{\"h\":\"1.2 基本概念\"},\"136\":{\"h\":\"2. 图的存储结构\"},\"137\":{\"h\":\"2.1 邻接矩阵存储\"},\"138\":{\"h\":\"2.2 邻接表储存\"},\"139\":{\"h\":\"3. 图的遍历\"},\"140\":{\"h\":\"3.1 深度优先遍历\"},\"141\":{\"h\":\"3.2 广度优先遍历\"},\"142\":{\"h\":\"3.3 一笔画问题\"},\"143\":{\"h\":\"3.4 哈密尔顿回路\"},\"144\":{\"h\":\"同余\"},\"145\":{\"h\":\"1. 同余的定义\"},\"146\":{\"h\":\"2. 同余的性质\"},\"147\":{\"h\":\"2.1 常用性质\"},\"148\":{\"h\":\"2.2 费尔马小定理\"},\"149\":{\"h\":\"3. 剩余类和完全剩余系\"},\"150\":{\"h\":\"3.1 剩余类定义\"},\"151\":{\"h\":\"3.2 剩余类性质\"},\"152\":{\"h\":\"3.3 完全剩余系\"},\"153\":{\"h\":\"4. 不定方程\"},\"154\":{\"h\":\"5. 孙子定理\"},\"155\":{\"h\":\"费马多边形定理\"},\"156\":{\"h\":\"1. 多边形数\"},\"157\":{\"h\":\"2. 费马多边形定理\"},\"158\":{\"h\":\"3. 四平方和定理\"},\"159\":{\"h\":\"4. 完全平方和问题\"},\"160\":{\"h\":\"4.1 四平方和定理解答\"},\"161\":{\"h\":\"4.2 动态规划\"},\"162\":{\"h\":\"5. 费马平方和定理\"},\"163\":{\"h\":\"最大公约数与最小公倍数\"},\"164\":{\"h\":\"1. 最大公约数定义\"},\"165\":{\"h\":\"2. 欧几里得算法\"},\"166\":{\"h\":\"2.1 递归法\"},\"167\":{\"h\":\"2.2 快速实现\"},\"168\":{\"h\":\"3. Stein 算法\"},\"169\":{\"h\":\"4. 扩展欧几里得算法\"},\"170\":{\"h\":\"5. 最小公倍数\"},\"171\":{\"h\":\"3. 标准库实现\"},\"172\":{\"h\":\"数论\"},\"173\":{\"h\":\"素数筛法\"},\"174\":{\"h\":\"1. 暴力筛法\"},\"175\":{\"h\":\"2. 埃拉托斯特尼筛法\"},\"176\":{\"h\":\"2. 欧拉筛法\"},\"177\":{\"h\":\"路径规划算法\"},\"178\":{\"h\":\"1. Dijkstra 算法\"},\"179\":{\"h\":\"2. A* 算法\"},\"180\":{\"h\":\"3. D* 算法\"},\"181\":{\"h\":\"4. LPA* 算法\"},\"182\":{\"h\":\"5. D* lite 算法\"},\"183\":{\"h\":\"总结\"},\"184\":{\"h\":\"二项分布\"},\"185\":{\"h\":\"概率与统计\"},\"186\":{\"h\":\"拒绝采样\"},\"187\":{\"h\":\"1. 拒绝采样的定义\"},\"188\":{\"h\":\"2. 例题\"},\"189\":{\"h\":\"2.1 用 Rand7 实现 Rand10\"},\"190\":{\"h\":\"二项式定理\"},\"191\":{\"h\":\"函数\"},\"192\":{\"h\":\"函数\"},\"193\":{\"h\":\"柯西不等式\"},\"194\":{\"h\":\"1. 柯西不等式表述\"},\"195\":{\"h\":\"2. 重要结论\"},\"196\":{\"h\":\"附录：构造函数证明柯西不等式\"},\"197\":{\"h\":\"不等式\"},\"198\":{\"h\":\"均值不等式\"},\"199\":{\"h\":\"1. 基本不等式\"},\"200\":{\"h\":\"2. 平均数\"},\"201\":{\"h\":\"3. 均值不等式\"},\"202\":{\"h\":\"附录：结论推广\"},\"203\":{\"h\":\"等差数列\"},\"204\":{\"h\":\"1. 等差数列定义\"},\"205\":{\"h\":\"2. 等差数列的性质\"},\"206\":{\"h\":\"数列\"},\"207\":{\"h\":\"数列简介\"},\"208\":{\"h\":\"1. 数列的定义\"},\"209\":{\"h\":\"2. 数列的常见性质\"},\"210\":{\"h\":\"2.1 单调性\"},\"211\":{\"h\":\"2.2 有限性\"},\"212\":{\"h\":\"2.3 有界性\"},\"213\":{\"h\":\"2.4 收敛性\"},\"214\":{\"h\":\"2.5 周期性\"},\"215\":{\"h\":\"3. 常见的数列\"},\"216\":{\"h\":\"3.1 等差数列\"},\"217\":{\"h\":\"3.2 等比数列\"},\"218\":{\"h\":\"3.3 等和数列\"},\"219\":{\"h\":\"1. 随机事件与概率\"},\"220\":{\"h\":\"1.1 随机试验\"},\"221\":{\"h\":\"1.2 概率的定义\"},\"222\":{\"h\":\"概率论\"},\"223\":{\"h\":\"容斥原理\"},\"224\":{\"h\":\"1. 集合的划分\"},\"225\":{\"h\":\"2. 容斥公式\"},\"226\":{\"h\":\"3. 筛法公式\"},\"227\":{\"h\":\"集合论\"},\"228\":{\"h\":\"集合\"},\"229\":{\"h\":\"1. 集合\"},\"230\":{\"h\":\"1.1 集合的定义\"},\"231\":{\"h\":\"1.2 集合的表示\"},\"232\":{\"h\":\"1.3 常见的集合\"},\"233\":{\"h\":\"2. 区间\"},\"234\":{\"h\":\"3. 集合的运算\"},\"235\":{\"h\":\"4. 集合运算的性质\"},\"236\":{\"h\":\"4.1 基础结论\"},\"237\":{\"h\":\"4.2 运算性质\"},\"238\":{\"h\":\"三角函数\"},\"239\":{\"h\":\"三角函数\"},\"240\":{\"h\":\"三角恒等式\"},\"241\":{\"h\":\"1. 概念 [1] [2]\"},\"242\":{\"h\":\"1.1 勾股定理\"},\"243\":{\"h\":\"1.2 半角公式\"},\"244\":{\"h\":\"1.3 二倍角公式\"},\"245\":{\"h\":\"1.4 三倍角公式\"},\"246\":{\"h\":\"1.5 和差化积\"},\"247\":{\"h\":\"1.6 积化合差\"},\"248\":{\"h\":\"1.7 万能公式\"},\"249\":{\"h\":\"1. 绪论\"},\"250\":{\"h\":\"1.1 什么是编译\"},\"251\":{\"h\":\"1.1.1 计算机程序设计语言及编译\"},\"252\":{\"h\":\"1.1.2 编译器在语言处理系统中的位置\"},\"253\":{\"h\":\"1.2 编译系统的结构\"},\"254\":{\"h\":\"1.2.1 人工英汉翻译的例子\"},\"255\":{\"h\":\"1.2.2 编译器的结构\"},\"256\":{\"h\":\"1.3 词法分析概述\"},\"257\":{\"h\":\"1.3.1 词法分析的主要任务\"},\"258\":{\"h\":\"1.3.2 词法分析后得到的 token 序列\"},\"259\":{\"h\":\"1.4 语法分析概述\"},\"260\":{\"h\":\"1.4.1 语法分析器\"},\"261\":{\"h\":\"1.4.2 赋值语句分析树\"},\"262\":{\"h\":\"1.4.3 变量声明语句的分析树\"},\"263\":{\"h\":\"1.5 语义分析概述\"},\"264\":{\"h\":\"1.5.1 语义分析的主要任务\"},\"265\":{\"h\":\"1.5.2 收集标识符的属性信息\"},\"266\":{\"h\":\"1.5.3 语义检查\"},\"267\":{\"h\":\"1.6 中间代码生成和编译器后端\"},\"268\":{\"h\":\"1.6.1 常用的中间表示形式\"},\"269\":{\"h\":\"1.6.2 中间代码生成的例子\"},\"270\":{\"h\":\"1.6.3 目标代码生成\"},\"271\":{\"h\":\"2. 程序设计语言及其文法\"},\"272\":{\"h\":\"2.1 词法语法分析基本概念\"},\"273\":{\"h\":\"2.1.1 字母表\"},\"274\":{\"h\":\"2.1.2 字母表上的运算\"},\"275\":{\"h\":\"2.1.3 串上的运算\"},\"276\":{\"h\":\"2.2 文法定义\"},\"277\":{\"h\":\"2.2.1 文法的定义\"},\"278\":{\"h\":\"2.2.2 简化后的算数表达式的文法\"},\"279\":{\"h\":\"2.2.3 产生式的简写\"},\"280\":{\"h\":\"2.2.4 符号约定\"},\"281\":{\"h\":\"2.3 语言的定义\"},\"282\":{\"h\":\"2.3.1 推导和归约\"},\"283\":{\"h\":\"2.3.2 句型和句子\"},\"284\":{\"h\":\"2.3.3 练习：写出无符号整数和浮点数的文法\"},\"285\":{\"h\":\"2.3.4 语言上的运算\"},\"286\":{\"h\":\"2.4 文法的分类\"},\"287\":{\"h\":\"2.4.1 Chomsky 文法分类体系\"},\"288\":{\"h\":\"2.4.2 四种文法的关系\"},\"289\":{\"h\":\"2.5 CFG 的分析树\"},\"290\":{\"h\":\"2.5.1 举例分析\"},\"291\":{\"h\":\"2.5.2 分析树推导的图形化表示\"},\"292\":{\"h\":\"2.5.3 句型的短语\"},\"293\":{\"h\":\"2.5.4 二义性文法\"},\"294\":{\"h\":\"2.5.5 二义性文法的判定\"},\"295\":{\"h\":\"3. 词法分析\"},\"296\":{\"h\":\"3.1 正则表达式\"},\"297\":{\"h\":\"3.1.1 正则表达式定义\"},\"298\":{\"h\":\"3.1.2 正则表达式与正则文法是等价的\"},\"299\":{\"h\":\"3.2 正则定义\"},\"300\":{\"h\":\"3.2.1 什么是正则定义\"},\"301\":{\"h\":\"3.2.2 C 语言标识符的正则定义\"},\"302\":{\"h\":\"3.3 有穷自动机\"},\"303\":{\"h\":\"3.3.1 有穷自动机定义\"},\"304\":{\"h\":\"3.3.2 FA 的典型例子\"},\"305\":{\"h\":\"3.3.3 FA 接收的语言\"},\"306\":{\"h\":\"3.4 有穷自动机的分类\"},\"307\":{\"h\":\"3.4.1 确定的有穷自动机（DFA）\"},\"308\":{\"h\":\"3.4.2 非确定的有穷自动机（NFA）\"},\"309\":{\"h\":\"3.4.3 DFA 和 NFA 的等价性\"},\"310\":{\"h\":\"3.4.4 带 “ε-边” 的 NFA\"},\"311\":{\"h\":\"3.4.5 DFA 算法实现\"},\"312\":{\"h\":\"3.5 从正则表达式到有穷自动机\"},\"313\":{\"h\":\"3.5.1 构造方法\"},\"314\":{\"h\":\"3.5.2 根据 RE 构造 NFA\"},\"315\":{\"h\":\"3.6 从 NFA 到 DFA 的转换\"},\"316\":{\"h\":\"3.6.1 转换示例\"},\"317\":{\"h\":\"3.6.2 带有空边的 NFA 到 DFA\"},\"318\":{\"h\":\"3.6.3 子集构造法（Subset Construction）\"},\"319\":{\"h\":\"3.6.4 计算 ε _ c l o s u r e ( T ) \\\\mathrm{\\\\varepsilon\\\\_closure}(T) ε _closure ( T )\"},\"320\":{\"h\":\"3.7 识别单词的 DFA\"},\"321\":{\"h\":\"3.7.1 定义\"},\"322\":{\"h\":\"3.7.2 识别注释的 DFA\"},\"323\":{\"h\":\"3.7.3 识别 Token 的 DFA\"},\"324\":{\"h\":\"3.7.4 词法分析阶段中的错误处理\"},\"325\":{\"h\":\"集合\"},\"326\":{\"h\":\"给 JavaScript 读者的集合指南\"},\"327\":{\"h\":\"集合 ADT\"},\"328\":{\"h\":\"1. 集合的定义\"},\"329\":{\"h\":\"2. 集合 ADT\"},\"330\":{\"h\":\"二叉树\"},\"331\":{\"h\":\"树\"},\"332\":{\"h\":\"树\"},\"333\":{\"h\":\"1. 基础概念\"},\"334\":{\"h\":\"1.1 无根树\"},\"335\":{\"h\":\"1.2 有根树\"},\"336\":{\"h\":\"1.3 二叉树的性质\"},\"337\":{\"h\":\"2. 树的储存结构\"},\"338\":{\"h\":\"2.1 父结点表示法\"},\"339\":{\"h\":\"2.2 子结点表示法\"},\"340\":{\"h\":\"2.3 父亲孩子表示法\"},\"341\":{\"h\":\"2.4 孩子兄弟表示法\"},\"342\":{\"h\":\"字典树\"},\"343\":{\"h\":\"1. 字典树的定义\"},\"344\":{\"h\":\"0-1 背包\"},\"345\":{\"h\":\"1. 0-1 背包理论\"},\"346\":{\"h\":\"2. 基本思路\"},\"347\":{\"h\":\"3. 滚动数组\"},\"348\":{\"h\":\"4. 模板总结\"},\"349\":{\"h\":\"5. 获取背包的内容\"},\"350\":{\"h\":\"附录：背包与贪心问题\"},\"351\":{\"h\":\"完全背包\"},\"352\":{\"h\":\"1. 完全背包定义\"},\"353\":{\"h\":\"2. 模板总结\"},\"354\":{\"h\":\"3. 获取完全背包内的物品\"},\"355\":{\"h\":\"背包问题\"}},\"dirtCount\":0,\"index\":[[\"获取完全背包内的物品\",{\"0\":{\"354\":1}}],[\"获取背包的内容\",{\"0\":{\"349\":1}}],[\"模板总结\",{\"0\":{\"348\":1,\"353\":1}}],[\"模意义下取幂\",{\"0\":{\"79\":1}}],[\"滚动数组\",{\"0\":{\"347\":1}}],[\"背包问题\",{\"0\":{\"355\":1}}],[\"背包与贪心问题\",{\"0\":{\"350\":1}}],[\"背包理论\",{\"0\":{\"345\":1}}],[\"背包\",{\"0\":{\"344\":1}}],[\"0\",{\"0\":{\"344\":1,\"345\":1}}],[\"字典树的定义\",{\"0\":{\"343\":1}}],[\"字典树\",{\"0\":{\"342\":1}}],[\"字母表上的运算\",{\"0\":{\"274\":1}}],[\"字母表\",{\"0\":{\"273\":1}}],[\"孩子兄弟表示法\",{\"0\":{\"341\":1}}],[\"父亲孩子表示法\",{\"0\":{\"340\":1}}],[\"父结点表示法\",{\"0\":{\"338\":1}}],[\"子结点表示法\",{\"0\":{\"339\":1}}],[\"子集构造法\",{\"0\":{\"318\":1}}],[\"无根树\",{\"0\":{\"334\":1}}],[\"无符号右移\",{\"0\":{\"62\":1}}],[\"树的储存结构\",{\"0\":{\"337\":1}}],[\"树\",{\"0\":{\"331\":1,\"332\":1}}],[\"树形前缀和\",{\"0\":{\"91\":1}}],[\"读者的集合指南\",{\"0\":{\"326\":1}}],[\"javascript\",{\"0\":{\"326\":1}}],[\"给\",{\"0\":{\"326\":1}}],[\"识别\",{\"0\":{\"323\":1}}],[\"识别注释的\",{\"0\":{\"322\":1}}],[\"识别单词的\",{\"0\":{\"320\":1}}],[\"varepsilon\",{\"0\":{\"319\":1}}],[\"mathrm\",{\"0\":{\"319\":1}}],[\"t\",{\"0\":{\"319\":3}}],[\"token\",{\"0\":{\"258\":1,\"323\":1}}],[\"e\",{\"0\":{\"319\":1}}],[\"u\",{\"0\":{\"319\":1}}],[\"转换示例\",{\"0\":{\"316\":1}}],[\"到\",{\"0\":{\"315\":1,\"317\":1}}],[\"从\",{\"0\":{\"315\":1}}],[\"从正则表达式到有穷自动机\",{\"0\":{\"312\":1}}],[\"r\",{\"0\":{\"319\":1}}],[\"re\",{\"0\":{\"314\":1}}],[\"rand10\",{\"0\":{\"189\":1}}],[\"rand7\",{\"0\":{\"189\":1}}],[\"根据\",{\"0\":{\"314\":1}}],[\"构造\",{\"0\":{\"314\":1}}],[\"构造方法\",{\"0\":{\"313\":1}}],[\"构造函数证明柯西不等式\",{\"0\":{\"196\":1}}],[\"边\",{\"0\":{\"310\":1}}],[\"ε\",{\"0\":{\"310\":1,\"319\":2}}],[\"带有空边的\",{\"0\":{\"317\":1}}],[\"带\",{\"0\":{\"310\":1}}],[\"和\",{\"0\":{\"309\":1}}],[\"和差化积\",{\"0\":{\"246\":1}}],[\"确定的有穷自动机\",{\"0\":{\"307\":1}}],[\"接收的语言\",{\"0\":{\"305\":1}}],[\"的转换\",{\"0\":{\"315\":1}}],[\"的\",{\"0\":{\"310\":1,\"323\":1}}],[\"的等价性\",{\"0\":{\"309\":1}}],[\"的典型例子\",{\"0\":{\"304\":1}}],[\"的分析树\",{\"0\":{\"289\":1}}],[\"fa\",{\"0\":{\"304\":1,\"305\":1}}],[\"fibonacci\",{\"0\":{\"132\":1}}],[\"什么是正则定义\",{\"0\":{\"300\":1}}],[\"什么是编译\",{\"0\":{\"250\":1}}],[\"正则定义\",{\"0\":{\"299\":1}}],[\"正则表达式与正则文法是等价的\",{\"0\":{\"298\":1}}],[\"正则表达式定义\",{\"0\":{\"297\":1}}],[\"正则表达式\",{\"0\":{\"296\":1}}],[\"句型的短语\",{\"0\":{\"292\":1}}],[\"句型和句子\",{\"0\":{\"283\":1}}],[\"分析树推导的图形化表示\",{\"0\":{\"291\":1}}],[\"分数规划\",{\"0\":{\"50\":1}}],[\"举例分析\",{\"0\":{\"290\":1}}],[\"四种文法的关系\",{\"0\":{\"288\":1}}],[\"四平方和定理解答\",{\"0\":{\"160\":1}}],[\"四平方和定理\",{\"0\":{\"158\":1}}],[\"写出无符号整数和浮点数的文法\",{\"0\":{\"284\":1}}],[\"练习\",{\"0\":{\"284\":1}}],[\"推导和归约\",{\"0\":{\"282\":1}}],[\"符号约定\",{\"0\":{\"280\":1}}],[\"符号相同\",{\"0\":{\"68\":1}}],[\"产生式的简写\",{\"0\":{\"279\":1}}],[\"简化后的算数表达式的文法\",{\"0\":{\"278\":1}}],[\"简化的\",{\"0\":{\"120\":1}}],[\"文法分类体系\",{\"0\":{\"287\":1}}],[\"文法的分类\",{\"0\":{\"286\":1}}],[\"文法的定义\",{\"0\":{\"277\":1}}],[\"文法定义\",{\"0\":{\"276\":1}}],[\"串上的运算\",{\"0\":{\"275\":1}}],[\"词法语法分析基本概念\",{\"0\":{\"272\":1}}],[\"词法分析阶段中的错误处理\",{\"0\":{\"324\":1}}],[\"词法分析\",{\"0\":{\"295\":1}}],[\"词法分析后得到的\",{\"0\":{\"258\":1}}],[\"词法分析的主要任务\",{\"0\":{\"257\":1}}],[\"词法分析概述\",{\"0\":{\"256\":1}}],[\"程序设计语言及其文法\",{\"0\":{\"271\":1}}],[\"目标代码生成\",{\"0\":{\"270\":1}}],[\"目录\",{\"0\":{\"110\":1}}],[\"中间代码生成的例子\",{\"0\":{\"269\":1}}],[\"中间代码生成和编译器后端\",{\"0\":{\"267\":1}}],[\"收集标识符的属性信息\",{\"0\":{\"265\":1}}],[\"收敛性\",{\"0\":{\"213\":1}}],[\"变量声明语句的分析树\",{\"0\":{\"262\":1}}],[\"赋值语句分析树\",{\"0\":{\"261\":1}}],[\"语义检查\",{\"0\":{\"266\":1}}],[\"语义分析的主要任务\",{\"0\":{\"264\":1}}],[\"语义分析概述\",{\"0\":{\"263\":1}}],[\"语法分析器\",{\"0\":{\"260\":1}}],[\"语法分析概述\",{\"0\":{\"259\":1}}],[\"语言标识符的正则定义\",{\"0\":{\"301\":1}}],[\"语言上的运算\",{\"0\":{\"285\":1}}],[\"语言的定义\",{\"0\":{\"281\":1}}],[\"语言\",{\"0\":{\"47\":1}}],[\"序列\",{\"0\":{\"258\":1}}],[\"人工英汉翻译的例子\",{\"0\":{\"254\":1}}],[\"编译器的结构\",{\"0\":{\"255\":1}}],[\"编译器在语言处理系统中的位置\",{\"0\":{\"252\":1}}],[\"编译系统的结构\",{\"0\":{\"253\":1}}],[\"编译原理\",{\"0\":{\"93\":1}}],[\"计算\",{\"0\":{\"319\":1}}],[\"计算机程序设计语言及编译\",{\"0\":{\"251\":1}}],[\"计数原理\",{\"0\":{\"25\":1}}],[\"绪论\",{\"0\":{\"249\":1}}],[\"万能公式\",{\"0\":{\"248\":1}}],[\"积化合差\",{\"0\":{\"247\":1}}],[\"半角公式\",{\"0\":{\"243\":1}}],[\"勾股定理\",{\"0\":{\"242\":1}}],[\"概念\",{\"0\":{\"241\":1}}],[\"概率论\",{\"0\":{\"222\":1}}],[\"概率的定义\",{\"0\":{\"221\":1}}],[\"概率与统计\",{\"0\":{\"185\":1}}],[\"三倍角公式\",{\"0\":{\"245\":1}}],[\"三角恒等式\",{\"0\":{\"240\":1}}],[\"三角函数\",{\"0\":{\"238\":1,\"239\":1}}],[\"三分法\",{\"0\":{\"51\":1}}],[\"运算性质\",{\"0\":{\"237\":1}}],[\"区间\",{\"0\":{\"233\":1}}],[\"集合运算的性质\",{\"0\":{\"235\":1}}],[\"集合的运算\",{\"0\":{\"234\":1}}],[\"集合的表示\",{\"0\":{\"231\":1}}],[\"集合的定义\",{\"0\":{\"230\":1,\"328\":1}}],[\"集合的划分\",{\"0\":{\"224\":1}}],[\"集合\",{\"0\":{\"228\":1,\"229\":1,\"325\":1,\"327\":1,\"329\":1}}],[\"集合论\",{\"0\":{\"227\":1}}],[\"筛法公式\",{\"0\":{\"226\":1}}],[\"容斥公式\",{\"0\":{\"225\":1}}],[\"容斥原理\",{\"0\":{\"223\":1}}],[\"随机试验\",{\"0\":{\"220\":1}}],[\"随机事件与概率\",{\"0\":{\"219\":1}}],[\"等和数列\",{\"0\":{\"218\":1}}],[\"等比数列\",{\"0\":{\"217\":1}}],[\"等差数列的性质\",{\"0\":{\"205\":1}}],[\"等差数列定义\",{\"0\":{\"204\":1}}],[\"等差数列\",{\"0\":{\"203\":1,\"216\":1}}],[\"周期性\",{\"0\":{\"214\":1}}],[\"有根树\",{\"0\":{\"335\":1}}],[\"有穷自动机的分类\",{\"0\":{\"306\":1}}],[\"有穷自动机定义\",{\"0\":{\"303\":1}}],[\"有穷自动机\",{\"0\":{\"302\":1}}],[\"有界性\",{\"0\":{\"212\":1}}],[\"有限性\",{\"0\":{\"211\":1}}],[\"单调性\",{\"0\":{\"210\":1}}],[\"结论推广\",{\"0\":{\"202\":1}}],[\"平均数\",{\"0\":{\"200\":1}}],[\"平衡三进制\",{\"0\":{\"14\":1}}],[\"均值不等式\",{\"0\":{\"198\":1,\"201\":1}}],[\"不等式\",{\"0\":{\"197\":1}}],[\"不定方程\",{\"0\":{\"153\":1}}],[\"重要结论\",{\"0\":{\"195\":1}}],[\"柯西不等式表述\",{\"0\":{\"194\":1}}],[\"柯西不等式\",{\"0\":{\"193\":1}}],[\"用\",{\"0\":{\"189\":1}}],[\"拒绝采样的定义\",{\"0\":{\"187\":1}}],[\"拒绝采样\",{\"0\":{\"186\":1}}],[\"总结\",{\"0\":{\"183\":1}}],[\"l\",{\"0\":{\"319\":1}}],[\"lite\",{\"0\":{\"182\":1}}],[\"lpa\",{\"0\":{\"181\":1}}],[\"dfa\",{\"0\":{\"307\":1,\"309\":1,\"311\":1,\"315\":1,\"317\":1,\"320\":1,\"322\":1,\"323\":1}}],[\"d\",{\"0\":{\"180\":1,\"182\":1}}],[\"dijkstra\",{\"0\":{\"178\":1}}],[\"divisor\",{\"0\":{\"121\":1}}],[\"路径规划算法\",{\"0\":{\"177\":1}}],[\"欧拉筛法\",{\"0\":{\"176\":1}}],[\"欧几里得算法\",{\"0\":{\"165\":1}}],[\"埃拉托斯特尼筛法\",{\"0\":{\"175\":1}}],[\"暴力筛法\",{\"0\":{\"174\":1}}],[\"素数筛法\",{\"0\":{\"173\":1}}],[\"扩展欧几里得算法\",{\"0\":{\"169\":1}}],[\"递归法\",{\"0\":{\"166\":1}}],[\"递归版本\",{\"0\":{\"77\":1}}],[\"最小公倍数\",{\"0\":{\"170\":1}}],[\"最大公约数定义\",{\"0\":{\"164\":1}}],[\"最大公约数与最小公倍数\",{\"0\":{\"163\":1}}],[\"最低有效位\",{\"0\":{\"70\":1}}],[\"完全背包定义\",{\"0\":{\"352\":1}}],[\"完全背包\",{\"0\":{\"351\":1}}],[\"完全平方和问题\",{\"0\":{\"159\":1}}],[\"完全剩余系\",{\"0\":{\"152\":1}}],[\"多边形数\",{\"0\":{\"156\":1}}],[\"费马平方和定理\",{\"0\":{\"162\":1}}],[\"费马多边形定理\",{\"0\":{\"155\":1,\"157\":1}}],[\"费尔马小定理\",{\"0\":{\"148\":1}}],[\"孙子定理\",{\"0\":{\"154\":1}}],[\"剩余类性质\",{\"0\":{\"151\":1}}],[\"剩余类定义\",{\"0\":{\"150\":1}}],[\"剩余类和完全剩余系\",{\"0\":{\"149\":1}}],[\"常用的中间表示形式\",{\"0\":{\"268\":1}}],[\"常用性质\",{\"0\":{\"147\":1}}],[\"常见的集合\",{\"0\":{\"232\":1}}],[\"常见的数列\",{\"0\":{\"215\":1}}],[\"常见的公平组合游戏\",{\"0\":{\"119\":1}}],[\"常见的组合性质\",{\"0\":{\"33\":1}}],[\"常见算法\",{\"0\":{\"82\":1}}],[\"同余的性质\",{\"0\":{\"146\":1}}],[\"同余的定义\",{\"0\":{\"145\":1}}],[\"同余\",{\"0\":{\"144\":1}}],[\"哈密尔顿回路\",{\"0\":{\"143\":1}}],[\"一笔画问题\",{\"0\":{\"142\":1}}],[\"一般求解步骤\",{\"0\":{\"129\":1}}],[\"广度优先遍历\",{\"0\":{\"141\":1}}],[\"深度优先遍历\",{\"0\":{\"140\":1}}],[\"邻接表储存\",{\"0\":{\"138\":1}}],[\"邻接矩阵存储\",{\"0\":{\"137\":1}}],[\"图的遍历\",{\"0\":{\"139\":1}}],[\"图的存储结构\",{\"0\":{\"136\":1}}],[\"图的定义\",{\"0\":{\"134\":1}}],[\"图论\",{\"0\":{\"133\":1}}],[\"hdu1848\",{\"0\":{\"132\":1}}],[\"adt\",{\"0\":{\"327\":1,\"329\":1}}],[\"a\",{\"0\":{\"179\":1}}],[\"and\",{\"0\":{\"132\":1}}],[\"again\",{\"0\":{\"132\":2}}],[\"例题\",{\"0\":{\"131\":1,\"188\":1}}],[\"函数\",{\"0\":{\"128\":1,\"191\":1,\"192\":1}}],[\"函数的渐进的界\",{\"0\":{\"9\":1}}],[\"局面和其性质\",{\"0\":{\"127\":1}}],[\"定理\",{\"0\":{\"126\":1,\"130\":1}}],[\"定义\",{\"0\":{\"38\":1,\"321\":1}}],[\"s\",{\"0\":{\"319\":1}}],[\"subset\",{\"0\":{\"318\":1}}],[\"stein\",{\"0\":{\"168\":1}}],[\"stl\",{\"0\":{\"46\":1}}],[\"sg\",{\"0\":{\"126\":1,\"128\":1,\"130\":1}}],[\"wythoff\",{\"0\":{\"123\":1}}],[\"威佐夫博弈\",{\"0\":{\"123\":1}}],[\"bash\",{\"0\":{\"122\":1}}],[\"巴什博奕\",{\"0\":{\"122\":1}}],[\"除数博弈\",{\"0\":{\"121\":1}}],[\"game\",{\"0\":{\"120\":1,\"121\":1,\"122\":1,\"123\":1,\"124\":1}}],[\"博弈论\",{\"0\":{\"125\":1}}],[\"博弈论简介\",{\"0\":{\"115\":1}}],[\"博弈\",{\"0\":{\"120\":1,\"124\":1}}],[\"反常游戏\",{\"0\":{\"118\":1}}],[\"公平组合游戏\",{\"0\":{\"117\":1}}],[\"公式总结\",{\"0\":{\"63\":1}}],[\"公式和字体\",{\"0\":{\"17\":1}}],[\"非确定的有穷自动机\",{\"0\":{\"308\":1}}],[\"非公平组合游戏\",{\"0\":{\"116\":1}}],[\"非递归版本\",{\"0\":{\"78\":1}}],[\"动态规划\",{\"0\":{\"114\":1,\"161\":1}}],[\"动态数组\",{\"0\":{\"108\":1}}],[\"栈\",{\"0\":{\"113\":1}}],[\"队列\",{\"0\":{\"112\":1}}],[\"链表\",{\"0\":{\"111\":1}}],[\"使用紧凑数组\",{\"0\":{\"107\":1}}],[\"低层次数组\",{\"0\":{\"106\":1}}],[\"优化\",{\"0\":{\"100\":1,\"101\":1}}],[\"o\",{\"0\":{\"100\":1,\"101\":1,\"319\":1}}],[\"i\",{\"0\":{\"100\":1,\"101\":1}}],[\"i+1\",{\"0\":{\"69\":1}}],[\"竞赛指南\",{\"0\":{\"99\":1}}],[\"缩略词\",{\"0\":{\"98\":1}}],[\"术语表\",{\"0\":{\"97\":1}}],[\"高维前缀和\",{\"0\":{\"90\":1}}],[\"二叉树的性质\",{\"0\":{\"336\":1}}],[\"二叉树\",{\"0\":{\"330\":1}}],[\"二义性文法的判定\",{\"0\":{\"294\":1}}],[\"二义性文法\",{\"0\":{\"293\":1}}],[\"二倍角公式\",{\"0\":{\"244\":1}}],[\"二项式定理\",{\"0\":{\"190\":1}}],[\"二项分布\",{\"0\":{\"184\":1}}],[\"二维前缀和\",{\"0\":{\"89\":1}}],[\"二分答案\",{\"0\":{\"49\":1}}],[\"二分查找\",{\"0\":{\"43\":1}}],[\"二分算法\",{\"0\":{\"42\":1}}],[\"其他形式的前缀和\",{\"0\":{\"88\":1}}],[\"前缀操作\",{\"0\":{\"87\":1}}],[\"前缀和的推广\",{\"0\":{\"85\":1}}],[\"前缀和定义\",{\"0\":{\"84\":1}}],[\"前缀和\",{\"0\":{\"83\":1}}],[\"后缀和\",{\"0\":{\"86\":1}}],[\"快速实现\",{\"0\":{\"167\":1}}],[\"快速幂算法\",{\"0\":{\"76\":1}}],[\"快速幂\",{\"0\":{\"75\":1}}],[\"快速最小公倍数\",{\"0\":{\"66\":1}}],[\"性质\",{\"0\":{\"74\":1}}],[\"差分数组的定义\",{\"0\":{\"73\":1}}],[\"差分数组\",{\"0\":{\"72\":1}}],[\"绝对值\",{\"0\":{\"71\":1}}],[\"位\",{\"0\":{\"69\":1}}],[\"位运算总结\",{\"0\":{\"64\":1}}],[\"位运算详解\",{\"0\":{\"55\":1}}],[\"位运算优先级\",{\"0\":{\"54\":1}}],[\"位运算的功能\",{\"0\":{\"53\":1}}],[\"位运算\",{\"0\":{\"52\":1}}],[\"第\",{\"0\":{\"69\":1}}],[\"第一类斯特林数\",{\"0\":{\"41\":1}}],[\"判断奇偶\",{\"0\":{\"67\":1}}],[\"交换两个数\",{\"0\":{\"65\":1}}],[\"8\",{\"0\":{\"63\":1}}],[\"7\",{\"0\":{\"62\":1,\"71\":1,\"248\":1,\"320\":1,\"321\":1,\"322\":1,\"323\":1,\"324\":1}}],[\"右移\",{\"0\":{\"61\":1}}],[\"左移\",{\"0\":{\"60\":1}}],[\"异或\",{\"0\":{\"58\":1}}],[\"按位取反\",{\"0\":{\"59\":1}}],[\"按位或\",{\"0\":{\"57\":1}}],[\"按位与\",{\"0\":{\"56\":1}}],[\"6\",{\"0\":{\"51\":1,\"61\":1,\"70\":1,\"247\":1,\"267\":1,\"268\":1,\"269\":1,\"270\":1,\"315\":1,\"316\":1,\"317\":1,\"318\":1,\"319\":1}}],[\"python\",{\"0\":{\"48\":1,\"96\":1,\"105\":1}}],[\"closure\",{\"0\":{\"319\":2}}],[\"construction\",{\"0\":{\"318\":1}}],[\"cfg\",{\"0\":{\"289\":1}}],[\"chomsky\",{\"0\":{\"287\":1}}],[\"c\",{\"0\":{\"47\":1,\"301\":1,\"319\":1}}],[\"c++\",{\"0\":{\"46\":1,\"95\":1,\"101\":1,\"104\":1}}],[\"实现\",{\"0\":{\"46\":1,\"189\":1}}],[\"实验结果\",{\"0\":{\"4\":1}}],[\"标准库实现\",{\"0\":{\"45\":1,\"92\":1,\"171\":1}}],[\"代码实现\",{\"0\":{\"44\":1}}],[\"斐波那契数列\",{\"0\":{\"37\":1,\"80\":1}}],[\"斐波那契数和组合数\",{\"0\":{\"35\":1}}],[\"维空间和组合数\",{\"0\":{\"36\":1}}],[\"nfa\",{\"0\":{\"308\":1,\"309\":1,\"310\":1,\"314\":1,\"315\":1,\"317\":1}}],[\"nim\",{\"0\":{\"120\":2,\"124\":2}}],[\"n\",{\"0\":{\"36\":3}}],[\"附录\",{\"0\":{\"34\":1,\"196\":1,\"202\":1,\"350\":1}}],[\"生成函数\",{\"0\":{\"32\":1}}],[\"组合数学\",{\"0\":{\"39\":1}}],[\"组合的有趣性质\",{\"0\":{\"34\":1}}],[\"组合恒等式\",{\"0\":{\"31\":1}}],[\"组合\",{\"0\":{\"30\":1}}],[\"排列数\",{\"0\":{\"29\":1}}],[\"排列组合基础\",{\"0\":{\"28\":1}}],[\"排列组合\",{\"0\":{\"24\":1}}],[\"乘法原理\",{\"0\":{\"27\":1}}],[\"加法原理\",{\"0\":{\"26\":1}}],[\"数列的常见性质\",{\"0\":{\"209\":1}}],[\"数列的定义\",{\"0\":{\"208\":1}}],[\"数列简介\",{\"0\":{\"207\":1}}],[\"数列\",{\"0\":{\"206\":1}}],[\"数组的定义\",{\"0\":{\"103\":1}}],[\"数组\",{\"0\":{\"102\":1,\"104\":1,\"105\":1}}],[\"数组初始化\",{\"0\":{\"95\":1,\"96\":1}}],[\"数组优化\",{\"0\":{\"94\":1}}],[\"数论\",{\"0\":{\"23\":1,\"172\":1}}],[\"数学符号定义\",{\"0\":{\"16\":1}}],[\"数学表示\",{\"0\":{\"12\":1}}],[\"5\",{\"0\":{\"23\":1,\"50\":1,\"60\":1,\"69\":1,\"92\":1,\"124\":1,\"131\":1,\"132\":1,\"154\":1,\"162\":1,\"170\":1,\"182\":1,\"214\":1,\"246\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"289\":1,\"290\":1,\"291\":1,\"292\":1,\"293\":1,\"294\":2,\"311\":1,\"312\":1,\"313\":1,\"314\":1,\"349\":1}}],[\"求矩阵的快速幂\",{\"0\":{\"81\":1}}],[\"求积\",{\"0\":{\"22\":1}}],[\"求和\",{\"0\":{\"21\":1}}],[\"大型运算符\",{\"0\":{\"20\":1}}],[\"4\",{\"0\":{\"20\":1,\"21\":1,\"22\":1,\"49\":1,\"59\":1,\"64\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":2,\"69\":1,\"70\":1,\"71\":1,\"81\":1,\"119\":1,\"120\":1,\"121\":1,\"122\":1,\"123\":2,\"124\":1,\"130\":1,\"143\":1,\"153\":1,\"159\":1,\"160\":1,\"161\":1,\"169\":1,\"181\":1,\"213\":1,\"235\":1,\"236\":1,\"237\":1,\"245\":1,\"259\":1,\"260\":1,\"261\":1,\"262\":1,\"280\":1,\"285\":1,\"286\":1,\"287\":1,\"288\":1,\"293\":1,\"306\":1,\"307\":1,\"308\":1,\"309\":1,\"310\":2,\"311\":1,\"319\":1,\"324\":1,\"341\":1,\"348\":1}}],[\"证明中的符号\",{\"0\":{\"19\":1}}],[\"基础概念\",{\"0\":{\"333\":1}}],[\"基础结论\",{\"0\":{\"236\":1}}],[\"基础数据结构\",{\"0\":{\"109\":1}}],[\"基础数学知识\",{\"0\":{\"15\":1}}],[\"基本思路\",{\"0\":{\"346\":1}}],[\"基本不等式\",{\"0\":{\"199\":1}}],[\"基本概念\",{\"0\":{\"135\":1}}],[\"基本\",{\"0\":{\"18\":1}}],[\"斯特林数\",{\"0\":{\"40\":1}}],[\"斯特林近似\",{\"0\":{\"13\":1}}],[\"斯特林公式\",{\"0\":{\"11\":1}}],[\"3\",{\"0\":{\"8\":1,\"9\":1,\"19\":1,\"45\":1,\"46\":1,\"47\":1,\"48\":2,\"55\":1,\"56\":1,\"57\":1,\"58\":2,\"59\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":1,\"67\":1,\"80\":1,\"88\":1,\"89\":1,\"90\":1,\"91\":2,\"105\":1,\"106\":1,\"107\":1,\"108\":2,\"118\":1,\"122\":1,\"129\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":2,\"143\":1,\"149\":1,\"150\":1,\"151\":1,\"152\":2,\"158\":1,\"168\":1,\"171\":1,\"180\":1,\"201\":1,\"212\":1,\"215\":1,\"216\":1,\"217\":1,\"218\":2,\"226\":1,\"232\":1,\"234\":1,\"244\":1,\"256\":1,\"257\":1,\"258\":1,\"262\":1,\"266\":1,\"270\":1,\"275\":1,\"279\":1,\"281\":1,\"282\":1,\"283\":1,\"284\":2,\"285\":1,\"292\":1,\"295\":1,\"296\":1,\"297\":1,\"298\":1,\"299\":1,\"300\":1,\"301\":1,\"302\":2,\"303\":2,\"304\":2,\"305\":3,\"306\":1,\"307\":1,\"308\":1,\"309\":2,\"310\":1,\"311\":1,\"312\":1,\"313\":1,\"314\":1,\"315\":1,\"316\":1,\"317\":1,\"318\":2,\"319\":1,\"320\":1,\"321\":1,\"322\":1,\"323\":2,\"324\":1,\"336\":1,\"340\":1,\"347\":1,\"354\":1}}],[\"伪代码编写\",{\"0\":{\"7\":1}}],[\"2\",{\"0\":{\"4\":1,\"7\":1,\"13\":1,\"18\":1,\"22\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":2,\"33\":1,\"44\":1,\"47\":1,\"54\":1,\"57\":1,\"66\":1,\"74\":1,\"78\":1,\"79\":1,\"85\":1,\"86\":1,\"87\":2,\"90\":1,\"96\":1,\"104\":1,\"107\":1,\"117\":1,\"121\":1,\"128\":1,\"135\":1,\"136\":1,\"137\":1,\"138\":2,\"141\":1,\"146\":1,\"147\":1,\"148\":2,\"151\":1,\"157\":1,\"161\":1,\"165\":1,\"166\":1,\"167\":2,\"175\":1,\"176\":1,\"179\":1,\"188\":1,\"189\":1,\"195\":1,\"200\":1,\"205\":1,\"209\":1,\"210\":1,\"211\":2,\"212\":1,\"213\":1,\"214\":1,\"217\":1,\"221\":1,\"225\":1,\"231\":1,\"233\":1,\"237\":1,\"241\":1,\"243\":1,\"252\":1,\"253\":1,\"254\":1,\"255\":2,\"258\":1,\"261\":1,\"265\":1,\"269\":1,\"271\":1,\"272\":1,\"273\":1,\"274\":2,\"275\":1,\"276\":2,\"277\":2,\"278\":3,\"279\":2,\"280\":2,\"281\":1,\"282\":1,\"283\":2,\"284\":1,\"285\":1,\"286\":1,\"287\":1,\"288\":2,\"289\":1,\"290\":1,\"291\":2,\"292\":1,\"293\":1,\"294\":1,\"298\":1,\"299\":1,\"300\":1,\"301\":2,\"304\":1,\"308\":1,\"314\":1,\"317\":1,\"322\":1,\"329\":1,\"335\":1,\"337\":1,\"338\":1,\"339\":2,\"340\":1,\"341\":1,\"346\":1,\"353\":1}}],[\"1\",{\"0\":{\"3\":1,\"6\":1,\"9\":1,\"12\":1,\"17\":1,\"21\":1,\"25\":1,\"26\":2,\"27\":1,\"29\":1,\"32\":1,\"38\":1,\"41\":1,\"43\":1,\"46\":1,\"53\":1,\"56\":1,\"65\":1,\"73\":1,\"76\":1,\"77\":2,\"78\":1,\"84\":1,\"86\":1,\"89\":1,\"95\":1,\"98\":1,\"101\":1,\"103\":1,\"106\":1,\"116\":1,\"120\":1,\"127\":1,\"132\":1,\"134\":1,\"135\":1,\"137\":1,\"140\":1,\"145\":1,\"147\":1,\"150\":1,\"156\":1,\"160\":1,\"164\":1,\"166\":1,\"174\":1,\"178\":1,\"187\":1,\"189\":1,\"194\":1,\"199\":1,\"204\":1,\"208\":1,\"210\":1,\"216\":1,\"219\":1,\"220\":2,\"221\":1,\"224\":1,\"229\":1,\"230\":2,\"231\":1,\"232\":1,\"236\":1,\"241\":2,\"242\":2,\"243\":1,\"244\":1,\"245\":1,\"246\":1,\"247\":1,\"248\":1,\"249\":1,\"250\":2,\"251\":3,\"252\":2,\"253\":1,\"254\":2,\"255\":1,\"256\":1,\"257\":2,\"258\":1,\"259\":1,\"260\":2,\"261\":1,\"262\":1,\"263\":1,\"264\":2,\"265\":1,\"266\":1,\"267\":1,\"268\":2,\"269\":1,\"270\":1,\"272\":1,\"273\":2,\"274\":1,\"275\":1,\"277\":1,\"282\":1,\"287\":1,\"290\":1,\"296\":1,\"297\":2,\"298\":1,\"300\":1,\"303\":1,\"307\":1,\"313\":1,\"316\":1,\"321\":1,\"328\":1,\"333\":1,\"334\":2,\"335\":1,\"336\":1,\"338\":1,\"343\":1,\"344\":1,\"345\":2,\"352\":1}}],[\"算法实现\",{\"0\":{\"311\":1}}],[\"算法的数学基础\",{\"0\":{\"8\":1}}],[\"算法的基本概念\",{\"0\":{\"6\":1}}],[\"算法\",{\"0\":{\"5\":1,\"168\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":1,\"182\":1}}],[\"算法分析的目标\",{\"0\":{\"3\":1}}],[\"算法分析\",{\"0\":{\"2\":1,\"10\":1}}],[\"算法和数据结构笔记\",{\"0\":{\"0\":1}}],[\"相关领域\",{\"0\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
